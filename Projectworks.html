<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Tasks | Task Management</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { 
            font-family: 'Segoe UI', 'Roboto', sans-serif; 
            background: #f5f7fa; 
            color: #333; 
            margin: 0; 
            line-height: 1.5;
        }
        .container { 
            margin: 0 auto; 
            padding: 15px; 
        }
        .header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 15px; 
            gap: 10px; 
        }
        .btn { 
            display: inline-flex; 
            align-items: center; 
            gap: 6px; 
            padding: 8px 16px; 
            border-radius: 6px; 
            font-weight: 500; 
            cursor: pointer; 
            text-decoration: none; 
            border: none; 
            font-size: 14px; 
            transition: all 0.2s ease; 
        }
        .btn-outline { 
            background: none; 
            border: 1px solid #d1d5db; 
            color: #3b82f6; 
        }
        .btn-outline:hover { 
            background: #f3f4f6; 
        }
        .btn-primary { 
            background: #3b82f6; 
            color: #fff; 
        }
        .btn-primary:hover { 
            background: #2563eb; 
        }
        .project-title-sticky { 
            font-size: 19px; 
            font-weight: 700; 
            color: #3b82f6; 
            margin-bottom: 2px; 
        }
        .project-title { 
            font-size: 24px; 
            margin-bottom: 15px; 
            color: #3b82f6; 
            font-weight: 600; 
        }
        .filters-bar { 
            display: flex; 
            flex-wrap: wrap; 
            align-items: center; 
            gap: 10px; 
            padding: 10px; 
            background: #fff; 
            border-radius: 8px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
            margin-bottom: 15px;
            border: 1px solid #e5e7eb;
        }
        .filter-group { 
            display: flex; 
            align-items: center; 
            gap: 6px; 
            background: #f9fafb; 
            border-radius: 6px; 
            padding: 6px 12px; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05); 
            flex: 1 1 100px; 
            min-width: 100px; 
            max-width: 160px; 
        }
        .filter-label { 
            font-size: 12px; 
            font-weight: 600; 
            color: #6b7280; 
        }
        select { 
            border: 1px solid #d1d5db; 
            border-radius: 6px; 
            padding: 5px 8px; 
            background: #fff; 
            color: #333; 
            font-size: 12px; 
            min-width: 80px; 
        }
        select:focus { 
            outline: none; 
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        .main-table-wrap { 
            display: flex; 
            flex-direction: row; 
            align-items: stretch; 
            width: 100%; 
            transition: all 0.3s; 
            gap: 15px;
        }
        .card { 
            background: #fff; 
            padding: 15px; 
            border-radius: 8px; 
            border: 1px solid #e5e7eb; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.05); 
            margin-bottom: 0; 
            flex: 1 1 65%; 
            overflow-x: auto; 
            transition: flex-basis 0.3s, width 0.3s; 
        }
        .card.full-width { 
            border-radius: 8px; 
            flex: 1 1 100% !important; 
        }
        .table-responsive { 
            width: 100%; 
            overflow-x: auto; 
        }
        .task-table { 
            width: 100%; 
            border-collapse: collapse; 
            font-size: 13px; 
        }
        .task-table th, .task-table td { 
            padding: 8px 10px; 
            border-bottom: 1px solid #e5e7eb; 
            text-align: left;
        }
        .task-table th { 
            background: #f9fafb; 
            font-weight: 600; 
            font-size: 12px; 
            text-transform: uppercase; 
            letter-spacing: 0.3px; 
            position: sticky; 
            top: 0; 
            z-index: 1;
            color: #6b7280;
        }
        .task-table tr:nth-child(even) { 
            background: #f9fafb;
        }
        .task-table tr:hover { 
            background: #f3f4f6;
        }
        .status-badge { 
            display: inline-block; 
            padding: 4px 8px; 
            border-radius: 6px; 
            font-size: 12px; 
            font-weight: 600; 
        }
        .status-completed { 
            background: rgba(16, 185, 129, 0.1); 
            color: #10b981; 
            border: 1px solid #10b981; 
        }
        .status-ongoing { 
            background: rgba(245, 158, 11, 0.1); 
            color: #2d92ea; 
            border: 1px solid  #2d92ea; 
        }
        .status-pending { 
            background: rgba(107, 114, 128, 0.1); 
            color: #ffffff; 
            border: 1px solid #6b7280; 
        }
        .status-overdue {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border: 1px solid #ef4444;
        }
        .editable { 
            cursor: pointer; 
            border-radius: 4px; 
        }
        .editable:hover { 
            background: rgba(59, 130, 246, 0.05);
        }
        .editable-input, .editable-select { 
            width: 100%; 
            padding: 6px 8px !important; 
            border-radius: 6px; 
            border: 1px solid #d1d5db; 
            background: #fff; 
            color: #333; 
            font-size: 13px; 
        }
        .editable-input[data-field="taskDescription"], 
        .editable-input[data-field="assignedTo"], 
        .editable-select[data-field="taskDescription"], 
        .editable-select[data-field="assignedTo"] {
            text-align: left !important;
        }
        .cost-badge { 
            display: inline-block; 
            padding: 4px 8px; 
            border-radius: 6px; 
            font-size: 12px; 
            font-weight: 600; 
            background: rgba(59, 130, 246, 0.1); 
            color: #3b82f6; 
            border: 1px solid #3b82f6; 
        }
        .empty-state { 
            text-align: center; 
            padding: 30px; 
            color: #6b7280; 
        }
        .empty-state i { 
            font-size: 24px; 
            margin-bottom: 10px;
            color: #d1d5db;
        }
        .gantt-table-card { 
            background: #2d92ea; 
            border-radius: 8px; 
            border: 1px solid #e5e7eb; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.05); 
            margin-bottom: 0; 
            min-width: 300px; 
            max-width: 100%; 
            flex: 1 1 35%; 
            display: flex; 
            flex-direction: column; 
            justify-content: stretch; 
            transition: max-width 0.3s, min-width 0.3s;
        }
        .gantt-table-card.hide { 
            display: none !important; 
        }
        .gantt-table-header { 
            padding: 12px 15px; 
            display: flex; 
            align-items: center; 
            font-size: 14px; 
            color: #3b82f6; 
            font-weight: 600; 
            justify-content: space-between; 
            border-bottom: 1px solid #e5e7eb;
        }
        .gantt-table-toggle { 
            color: #3b82f6; 
            background: none; 
            border: none; 
            font-size: 16px; 
            cursor: pointer; 
            margin-left: 10px;
        }
        .toggle-bar { 
            position: absolute; 
            right: -40px; 
            top: 100px; 
            z-index: 50; 
            background: #fff; 
            color: #3b82f6; 
            border: 1px solid #3b82f6; 
            border-radius: 0 6px 6px 0; 
            padding: 8px 10px; 
            font-size: 16px; 
            cursor: pointer; 
            min-width: 24px; 
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .toggle-bar:hover { 
            background: #3b82f6; 
            color: #fff; 
        }
        .gantt-table-scroll { 
            overflow-x: auto; 
            height: 100%; 
            padding: 10px;
        }
        .gantt-table { 
            width: max-content; 
            border-collapse: collapse; 
            font-size: 12px; 
            height: 100%; 
            min-width: 500px;
        }
        .gantt-table th, .gantt-table td { 
            border: 1px solid #000000; 
            padding: 4px 6px; 
            text-align: center; 
            background:  #111827;
        }
        .gantt-table th { 
            background: #111827; 
            color:  #111827; 
            position: sticky; 
            top: 0; 
            z-index: 2; 
            font-size: 11px;
        }
        .gantt-bar { 
            background: #3b82f6; 
            border-radius: 4px; 
            height: 8px; 
            width: 90%; 
            margin: 0 auto;
        }
        .gantt-bar-empty { 
            background: #111827; 
            border: 1px dashed #111827;
        }
        .gantt-pct { 
            font-weight: bold; 
            font-size: 11px;
        }
        .gantt-table tr { 
            height: 28px; 
        }
        .hide { 
            display: none !important; 
        }
        .subtask-row td { 
            background:#111827; 
            color: #ffffff !important; 
        }
        .subtask-row td.subtask-desc { 
            padding-left: 30px !important; 
        }
        .subtask-arrow { 
            text-align: left; 
            padding-left: 15px; 
            color: #000000; 
            font-size: 16px; 
        }
        .main-task-expand { 
            cursor: pointer; 
            color: #3b82f6; 
            margin-right: 8px; 
        }
        .subsubtask-row td { 
            background:#111827; 
            color: #ffffff !important; 
        }
        .action-btn {
            background: #fff;
            color: #3b82f6;
            border: 1px solid #3b82f6;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s, color 0.2s, border 0.2s;
            margin: 2px 0;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .action-btn i {
            font-size: 14px;
        }
        .action-btn:hover,
        .action-btn:focus {
            background: #3b82f6;
            color: #fff;
        }
        .add-subtask-btn,
        .add-subsubtask-btn {
            background: none;
            color: inherit;
            border: none;
            box-shadow: none;
            padding: 0;
            margin: 0;
            font-size: inherit;
        }
        .delete-btn {
            background: #000000;
            color: #000000;
            border: 1px solid #000000;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 13px;
            cursor: pointer;
            margin-left: 8px;
            transition: background 0.2s, color 0.2s;
        }
        .delete-btn:hover {
            background: #ef4444;
            color: white;
        }
        @media (max-width: 800px) {
            .main-table-wrap { flex-direction: column; }
            .gantt-table-card { max-width: 100%; min-width: 100%; border-radius: 0 0 8px 8px; }
            .card { border-radius: 8px 8px 0 0;}
            .toggle-bar {
                right: 10px;
                top: auto;
                bottom: 10px;
                border-radius: 6px;
            }
        }
        .project-info-container {
            margin: 20px 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .project-header-card {
            background: #111827;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #e5e7eb;
        }
        .project-title-line {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e7eb;
        }
        .project-label {
            font-weight: bold;
            color: #4b5563;
            font-size: 14px;
        }
        .project-value {
            font-size: 16px;
            color: #111827;
        }
        .project-details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .detail-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .detail-value {
            color: #111827;
            margin-left: 5px;
        }
        .current-month-btn {
            background: #3b82f6;
            color:#111827;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 8px;
        }
        .current-month-btn:hover {
            background: #2563eb;
        }
        .fullscreen-btn {
            background: #3b82f6;
            color:#111827;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 8px;
        }
        .fullscreen-btn:hover {
            background: #2563eb;
        }
        .today-highlight {
            background-color: #f59e0b !important;
            color: #000 !important;
            font-weight: bold;
        }
        .current-month {
            background-color: rgba(59, 130, 246, 0.1) !important;
        }
        
        /* Dark mode styles */
        body.dark-mode {
            background: #1a1c23;
            color: #e5e7eb;
        }
        body.dark-mode .card,
        body.dark-mode .project-header-card,
        body.dark-mode .gantt-table-card {
            background: #252833;
            border-color: #374151;
        }
        body.dark-mode .task-table th,
        body.dark-mode .gantt-table th {
            background: #1f2937;
            color: #9ca3af;
        }
        body.dark-mode .task-table tr:nth-child(even),
        body.dark-mode .subtask-row td {
            background: #1f2937;
        }
        body.dark-mode .task-table tr:hover,
        body.dark-mode .subsubtask-row td {
            background: #2a3446;
        }
        body.dark-mode .task-table td,
        body.dark-mode .gantt-table td {
            border-color: #374151;
        }
        body.dark-mode .filter-group,
        body.dark-mode .filters-bar {
            background: #1f2937;
            border-color: #374151;
        }
        body.dark-mode select,
        body.dark-mode .editable-input,
        body.dark-mode .editable-select {
            background: #1f2937;
            border-color: #374151;
            color: #e5e7eb;
        }
        body.dark-mode .empty-state {
            color: #9ca3af;
        }
        body.dark-mode .project-label,
        body.dark-mode .filter-label {
            color: #9ca3af;
        }
        body.dark-mode .project-value,
        body.dark-mode .detail-value {
            color: #e5e7eb;
        }
        body.dark-mode .btn-outline {
            border-color: #374151;
            color: #3b82f6;
        }
        body.dark-mode .btn-outline:hover {
            background: #1f2937;
        }
        body.dark-mode .action-btn {
            background: #1f2937;
            border-color: #3b82f6;
            color: #3b82f6;
        }
        body.dark-mode .action-btn:hover {
            background: #3b82f6;
            color: #fff;
        }
        body.dark-mode .delete-btn {
            background: #1f2937;
            border-color: #111827;
            color:  #111827
        }
        body.dark-mode .delete-btn:hover {
            background: #111827;
            color: #fff;
        }
        
        /* Give Target styles */
        .give-target-cell {
            position: relative;
        }
        .give-target-overdue {
            color: #ef4444;
            font-weight: bold;
        }
        .give-target-ongoing {
            color: #3b82f6;
        }
        .give-target-completed {
            color: #10b981;
        }
        .give-target-pending {
            color: #6b7280;
        }
        
        /* Total row styles */
        .total-row {
            font-weight: bold;
            background-color: #f3f4f6 !important;
        }
        .total-row td {
            border-top: 2px solid #d1d5db;
        }
        body.dark-mode .total-row {
            background-color: #1f2937 !important;
        }
        body.dark-mode .total-row td {
            border-top: 2px solid #374151;
        }
        
        /* Search bar styles */
        .search-container {
            display: flex;
            align-items: center;
            background: #f9fafb;
            border-radius: 6px;
            padding: 6px 12px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            flex: 1 1 200px;
            min-width: 200px;
            max-width: 300px;
        }
        .search-input {
            border: none;
            background: transparent;
            padding: 5px;
            width: 100%;
            outline: none;
            color: #333;
        }
        body.dark-mode .search-container {
            background: #1f2937;
        }
        body.dark-mode .search-input {
            color: #e5e7eb;
        }

        /* Category header styles */
        .category-header {
            background: linear-gradient(135deg, #3b82f6, #1e40af);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .category-title {
            font-size: 24px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .category-icon {
            font-size: 28px;
        }
        .category-back-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }
        .category-back-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        /* Category transfer modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        body.dark-mode .modal-content {
            background: #252833;
            color: #e5e7eb;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e7eb;
        }
        body.dark-mode .modal-header {
            border-bottom-color: #374151;
        }
        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }
        .close-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #6b7280;
        }
        .close-btn:hover {
            color: #374151;
        }
        body.dark-mode .close-btn {
            color: #9ca3af;
        }
        body.dark-mode .close-btn:hover {
            color: #e5e7eb;
        }
        .category-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .category-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        .category-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .category-option.selected {
            border-color: #3b82f6;
        }
        .category-option-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }
        .category-option-name {
            font-size: 14px;
            font-weight: 500;
            text-align: center;
        }
        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        .transfer-btn {
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
        }
        .transfer-btn:hover {
            background: #2563eb;
        }
        .transfer-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        .cancel-btn {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
        }
        body.dark-mode .cancel-btn {
            background: #374151;
            color: #e5e7eb;
            border-color: #4b5563;
        }
        .cancel-btn:hover {
            background: #e5e7eb;
        }
        body.dark-mode .cancel-btn:hover {
            background: #4b5563;
        }
        .transfer-task-btn {
            background: #10b981;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 8px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .transfer-task-btn:hover {
            background: #059669;
        }

        /* Hide completed tasks toggle */
        .hide-completed-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #10b981;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        /* Status dropdown menu */
        .status-dropdown {
            position: relative;
            display: inline-block;
        }
        .status-dropdown-content {
            display: none;
            position: absolute;
            background-color: white;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 100;
            border-radius: 6px;
            overflow: hidden;
        }
        body.dark-mode .status-dropdown-content {
            background-color: #252833;
            border: 1px solid #374151;
        }
        .status-dropdown-content.show {
            display: block;
        }
        .status-option {
            padding: 10px 16px;
            cursor: pointer;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        body.dark-mode .status-option {
            border-bottom-color: #374151;
        }
        .status-option:last-child {
            border-bottom: none;
        }
        .status-option:hover {
            background-color: #f3f4f6;
        }
        body.dark-mode .status-option:hover {
            background-color: #374151;
        }
        .status-option.hide-option {
            border-top: 1px solid #e5e7eb;
            background-color: #f9fafb;
            font-weight: 600;
        }
        body.dark-mode .status-option.hide-option {
            border-top-color: #374151;
            background-color: #1f2937;
        }
    </style>
</head>
<body class="dark-mode">
    <div class="container">
        <!-- Category Header -->
        <div class="category-header" id="categoryHeader">
            <div class="category-title">
                <i class="fas fa-tools category-icon" id="categoryIcon"></i>
                <span id="categoryTitle">All Tasks</span>
            </div>
            <a href="cards.html?id=PROJECT_ID" class="btn category-back-btn" id="backToCategoriesBtn">
                <i class="fas fa-layer-group"></i> Back to Categories
            </a>
        </div>

        <div class="project-info-container">
            <div class="project-header-card">
                <div class="project-details-grid">
                    <div class="detail-item">
                        <a href="dashboard.html" class="btn btn-outline">
                            <i class="fas fa-arrow-left"></i> Back to Dashboard
                        </a>
                        <span class="project-label">PROJECT MANAGER:</span>
                        <span class="project-value">Christopher chishela</span>
                    </div>
                    <div class="detail-item">
                        <span class="project-label">SUPERVISOR:</span>
                        <span class="project-value">Orscar mushimbi</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="header">
            <div class="actions">
                <button class="btn btn-primary action-btn" id="addTaskBtn">
                    <i class="fas fa-plus"></i> Add Task
                </button>
                <a href="#" class="btn btn-outline action-btn" id="completedtasksBtn">
                    <i class="fas fa-check-circle"></i> Completed Tasks
                </a>
                <button class="btn btn-outline" id="toggleModeBtn">
                    <i class="fas fa-sun"></i> Light Mode
                </button>
            </div>
        </div>
        <div class="project-header" id="projectHeaderSticky">
            <div class="project-title-sticky" id="projectNameHeader">Project Tasks</div>
        </div>
        <div class="filters-bar">
            <div class="search-container">
                <i class="fas fa-search"></i>
                <input type="text" id="searchInput" class="search-input" placeholder="Search all fields...">
            </div>
            <div class="filter-group"><span class="filter-label">Status:</span>
                <select id="statusFilter">
                    <option value="">All</option>
                    <option value="COMPLETED">Completed</option>
                    <option value="ONGOING">Ongoing</option>
                    <option value="PENDING">Pending</option>
                    <option value="OVERDUE">Overdue</option>
                </select>
            </div>
            <div class="filter-group"><span class="filter-label">Month:</span>
                <select id="monthFilter">
                    <option value="">All Months</option>
                    <option value="1">January</option>
                    <option value="2">February</option>
                    <option value="3">March</option>
                    <option value="4">April</option>
                    <option value="5">May</option>
                    <option value="6">June</option>
                    <option value="7">July</option>
                    <option value="8">August</option>
                    <option value="9">September</option>
                    <option value="10">October</option>
                    <option value="11">November</option>
                    <option value="12">December</option>
                </select>
            </div>
            <div class="filter-group"><span class="filter-label">Year:</span>
                <select id="yearFilter">
                    <option value="">All Years</option>
                    <option value="2023">2023</option>
                    <option value="2024">2024</option>
                    <option value="2025">2025</option>
                    <option value="2026">2026</option>
                </select>
            </div>
            <div class="hide-completed-container">
                <span class="filter-label">Hide Completed:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="hideCompletedToggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
        <div class="main-table-wrap" id="mainTableWrap" style="position:relative;">
            <div class="card" id="mainCard">
                <div class="card-header" style="padding: 10px 0 15px 0;">
                    <h2 class="card-title" style="font-size:14px; margin:0; color:#3b82f6; font-weight:500">
                        <i class="fas fa-tasks"></i> <span id="tasksTitle">All Tasks</span>
                    </h2>
                </div>
                <div class="table-responsive">
                    <table class="task-table" id="taskTable">
                        <thead>
                            <tr>
                                <th></th>
                                <th>TASK ID</th>
                                <th>TASK LINE</th>
                                <th>DESCRIPTION</th>
                                <th>ASSIGNED</th>
                                <th class="editable">STATUS</th>
                                <th class="editable">START DATE</th>
                                <th class="editable">END DATE</th>
                                <th>GIVE TARGET</th>
                                <th class="duration">DURATION (Hrs)</th>
                                <th>MATERIAL COST</th>
                                <th>MAN COST</th>
                                <th>TOTAL COST</th>
                                <th>LOCATION</th>
                                <th>CATEGORY</th>
                                <th>ACTIONS</th>
                            </tr>
                        </thead>
                        <tbody id="taskList">
                            <!-- Example rows will be populated by JavaScript -->
                        </tbody>
                        <tfoot>
                            <tr class="total-row">
                                <td colspan="10" style="text-align: right; font-weight: bold;">TOTAL:</td>
                                <td id="totalMaterialCost"></td>
                                <td id="totalManCost"></td>
                                <td id="totalCost"></td>
                                <td colspan="3"></td>
                            </tr>
                        </tfoot>
                    </table>
                </div>
                <div class="empty-state" id="emptyState" style="display:none;">
                    <i class="fas fa-tasks"></i>
                    <p>No tasks found.</p>
                </div>
            </div>
            <!-- Table Gantt (side) -->
            <div class="gantt-table-card hide" id="ganttTableCard">
                <div class="gantt-table-header">
                    <span><i class="fas fa-calendar-alt"></i> Gantt Calendar</span>
                    <div>
                        <button class="current-month-btn" id="currentMonthBtn" title="Show current month">Current Month</button>
                        <button class="fullscreen-btn" id="fullscreenBtn" title="Toggle fullscreen"><i class="fas fa-expand"></i></button>
                        <button class="gantt-table-toggle action-btn" id="toggleGanttBtn" title="Show/hide calendar"><i class="fas fa-eye"></i></button>
                    </div>
                </div>
                <div class="gantt-table-scroll" id="ganttTableScroll" style="height:100%">
                    <table class="gantt-table" style="height:100%">
                        <thead id="ganttCalendarHead"></thead>
                        <tbody id="ganttCalendarBody"></tbody>
                    </table>
                </div>
            </div>
            <button id="showGanttBtn" class="toggle-bar action-btn" title="Show Gantt Calendar"><i class="fas fa-calendar-alt"></i></button>
        </div>
    </div>

    <!-- Category Transfer Modal -->
    <div class="modal-overlay" id="categoryTransferModal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Transfer Task to Category</h3>
                <button class="close-btn" id="closeModalBtn">&times;</button>
            </div>
            <div id="transferTaskInfo">
                <!-- Task info will be populated here -->
            </div>
            <div class="category-options" id="categoryOptions">
                <!-- Category options will be populated here -->
            </div>
            <div class="modal-actions">
                <button class="cancel-btn" id="cancelTransferBtn">Cancel</button>
                <button class="transfer-btn" id="confirmTransferBtn" disabled>Transfer Task</button>
            </div>
        </div>
    </div>

<script type="module">
   import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
import { getFirestore, doc, collection, query, where, onSnapshot, addDoc, updateDoc, deleteDoc, getDocs, getDoc, Timestamp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

// Debugging function
function debugLog(message, data = null) {
    console.log(`[DEBUG] ${message}`, data);
}

// Initialize Firebase
const firebaseConfig = {
    apiKey: "AIzaSyDXhhy94Aqmaav6X0UsfMcmsBT539-aheU",
    authDomain: "project-task-588c4.firebaseapp.com",
    projectId: "project-task-588c4",
    storageBucket: "project-task-588c4.appspot.com",
    messagingSenderId: "411882772509",
    appId: "1:411882772509:web:08d613186c101a99f38ef4",
    measurementId: "G-JMFLFYEM0F"
};

let db;
try {
    const app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    debugLog("Firebase initialized successfully");
} catch (e) {
    debugLog("Firebase initialization error", e);
    alert("Failed to initialize Firebase: " + e.message);
}

// Get project ID from URL
function getProjectIdFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    const projectId = urlParams.get('id');
    
    if (!projectId) {
        debugLog("No project ID found in URL");
        const errorMsg = "Project ID is missing from URL. Please access this page from the dashboard.";
        alert(errorMsg);
        throw new Error(errorMsg);
    }
    
    debugLog("Project ID from URL", projectId);
    return projectId;
}

// Get category from URL
function getCategoryFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('category');
}

const projectId = getProjectIdFromURL();
const currentCategory = getCategoryFromURL();

// Update back button URL
document.getElementById('backToCategoriesBtn').href = `cards.html?id=${projectId}`;

// Set completed tasks button href
document.getElementById('completedtasksBtn').href = `completedtask.html?id=${projectId}`;

// DOM Elements
const ganttTableCard = document.getElementById('ganttTableCard');
const ganttTableScroll = document.getElementById('ganttTableScroll');
const toggleGanttBtn = document.getElementById('toggleGanttBtn');
const showGanttBtn = document.getElementById('showGanttBtn');
const mainCard = document.getElementById('mainCard');
const currentMonthBtn = document.getElementById('currentMonthBtn');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const statusFilter = document.getElementById('statusFilter');
const monthFilter = document.getElementById('monthFilter');
const yearFilter = document.getElementById('yearFilter');
const searchInput = document.getElementById('searchInput');
const taskList = document.getElementById('taskList');
const emptyState = document.getElementById('emptyState');
const ganttCalendarBody = document.getElementById('ganttCalendarBody');
const ganttCalendarHead = document.getElementById('ganttCalendarHead');
const addTaskBtn = document.getElementById('addTaskBtn');
const toggleModeBtn = document.getElementById('toggleModeBtn');
const completedTasksBtn = document.getElementById('completedTasksBtn');
const categoryHeader = document.getElementById('categoryHeader');
const categoryTitle = document.getElementById('categoryTitle');
const categoryIcon = document.getElementById('categoryIcon');
const tasksTitle = document.getElementById('tasksTitle');
const hideCompletedToggle = document.getElementById('hideCompletedToggle');

// Category Transfer Modal Elements
const categoryTransferModal = document.getElementById('categoryTransferModal');
const closeModalBtn = document.getElementById('closeModalBtn');
const transferTaskInfo = document.getElementById('transferTaskInfo');
const categoryOptions = document.getElementById('categoryOptions');
const cancelTransferBtn = document.getElementById('cancelTransferBtn');
const confirmTransferBtn = document.getElementById('confirmTransferBtn');

// Category definitions with keywords for auto-categorization
const categories = {
    'general': {
        name: 'General Work',
        icon: 'fas fa-tools',
        color: '#4361ee',
        keywords: ['general', 'maintenance', 'repair', 'work', 'task', 'service']
    },
    'electrical': {
        name: 'Electrical Maintenance',
        icon: 'fas fa-bolt',
        color: '#f8961e',
        keywords: ['electrical', 'wiring', 'circuit', 'power', 'lighting', 'socket', 'switch', 'breaker', 'voltage', 'current', 'electric', 'wiring']
    },
    'plumbing': {
        name: 'Plumbing Maintenance',
        icon: 'fas fa-faucet',
        color: '#4cc9f0',
        keywords: ['plumbing', 'pipe', 'water', 'drain', 'faucet', 'toilet', 'sink', 'leak', 'valve', 'sewer', 'flush', 'tap']
    },
    'carpentry': {
        name: 'Carpentry Maintenance',
        icon: 'fas fa-hammer',
        color: '#7209b7',
        keywords: ['carpentry', 'wood', 'carpenter', 'frame', 'door', 'window', 'cabinet', 'furniture', 'saw', 'nail', 'screw', 'woodwork']
    },
    'welding': {
        name: 'Welding Maintenance',
        icon: 'fas fa-fire',
        color: '#f72585',
        keywords: ['welding', 'weld', 'metal', 'steel', 'arc', 'solder', 'fabrication', 'grinding', 'cutting', 'metalwork']
    },
    'networking': {
        name: 'Networking and IT Maintenance',
        icon: 'fas fa-network-wired',
        color: '#4895ef',
        keywords: ['network', 'it', 'computer', 'internet', 'wifi', 'server', 'cable', 'ethernet', 'router', 'switch', 'software', 'hardware', 'system']
    },
    'gardening': {
        name: 'Plants and Gardening Maintenance',
        icon: 'fas fa-leaf',
        color: '#38b000',
        keywords: ['gardening', 'garden', 'plant', 'landscape', 'lawn', 'tree', 'flower', 'irrigation', 'watering', 'hedge', 'grass', 'soil']
    }
};

// State variables
let ganttVisible = false;
let showCurrentMonthOnly = false;
let isFullscreen = false;
let allTasks = [];
let unsubMain = null;
let subUnsubs = {};
let expandedTasks = {};
let selectedTaskForTransfer = null;
let selectedCategoryForTransfer = null;
let hideCompleted = false;
let activeStatusDropdown = null;

// Update UI based on category
function updateCategoryUI() {
    if (currentCategory && categories[currentCategory]) {
        const category = categories[currentCategory];
        categoryTitle.textContent = category.name;
        categoryIcon.className = category.icon + ' category-icon';
        categoryHeader.style.background = `linear-gradient(135deg, ${category.color}, ${darkenColor(category.color, 20)})`;
        tasksTitle.textContent = `${category.name} Tasks`;
        document.title = `${category.name} | Task Management`;
    } else {
        categoryTitle.textContent = 'All Tasks';
        categoryIcon.className = 'fas fa-tasks category-icon';
        categoryHeader.style.background = 'linear-gradient(135deg, #3b82f6, #1e40af)';
        tasksTitle.textContent = 'All Tasks';
        document.title = 'Project Tasks | Task Management';
    }
}

// Helper function to darken color
function darkenColor(color, percent) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) - amt;
    const G = (num >> 8 & 0x00FF) - amt;
    const B = (num & 0x0000FF) - amt;
    return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
            (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
            (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
}

// Auto-categorize task based on description
function autoCategorizeTask(taskDescription) {
    if (!taskDescription) return 'general';
    
    const desc = taskDescription.toLowerCase();
    
    for (const [categoryId, category] of Object.entries(categories)) {
        if (categoryId === 'general') continue; // Skip general as it's the fallback
        
        for (const keyword of category.keywords) {
            if (desc.includes(keyword.toLowerCase())) {
                return categoryId;
            }
        }
    }
    
    return 'general'; // Default to general if no match found
}

// Helper functions
async function getProjectName(projectId) {
    const docRef = doc(db, "projectDashboard", projectId);
    const snap = await getDoc(docRef);
    return snap.exists() ? snap.data().name : "";
}

function getInitials(name) {
    return (name.match(/\b\w/g) || []).join('').toUpperCase();
}

async function getNextMainTaskNumber(projectId) {
    const snap = await getDocs(query(collection(db, "projectTasks"), where("projectId", "==", projectId)));
    let max = 0;
    snap.forEach(doc => {
        const task = doc.data();
        if (task.taskId) {
            const m = task.taskId.match(/-(\d+)$/);
            if (m) max = Math.max(max, parseInt(m[1], 10));
        }
    });
    return max + 1;
}

async function getNextSubtaskNumber(mainTaskId, mainDocId) {
    const snap = await getDocs(collection(db, "projectTasks", mainDocId, "subtasks"));
    let max = 0;
    snap.forEach(doc => {
        const task = doc.data();
        if (task.taskId && task.taskId.startsWith(mainTaskId + "-")) {
            const m = task.taskId.match(/-(\d+)$/);
            if (m) max = Math.max(max, parseInt(m[1], 10));
        }
    });
    return max + 1;
}

async function getNextSubSubtaskNumber(subTaskId, mainDocId, subDocId) {
    const snap = await getDocs(collection(db, "projectTasks", mainDocId, "subtasks", subDocId, "subsubtasks"));
    let max = 0;
    snap.forEach(doc => {
        const task = doc.data();
        if (task.taskId && task.taskId.startsWith(subTaskId + "-")) {
            const m = task.taskId.match(/-(\d+)$/);
            if (m) max = Math.max(max, parseInt(m[1], 10));
        }
    });
    return max + 1;
}

async function getWorkedHoursForTaskId(taskId) {
    if (!taskId) return 0;
    const q = query(collection(db, "locationHistory"), where("taskId", "==", taskId));
    let sum = 0;
    const snap = await getDocs(q);
    snap.forEach(doc => {
        const d = doc.data();
        if (d.mh && !isNaN(d.mh)) sum += Number(d.mh);
    });
    return sum;
}

async function getMaterialCostForTaskId(taskId) {
    if (!taskId) return 0;
    const q = query(collection(db, "materialsUsage"), where("taskId", "==", taskId));
    let sum = 0;
    const snap = await getDocs(q);
    
    // For inventory items - we need to get prices from materials collection
    const materialIds = new Set();
    snap.forEach(doc => {
        const d = doc.data();
        if (d.materialId) materialIds.add(d.materialId);
    });
    
    // Fetch prices for inventory items
    const materialPriceMap = {};
    await Promise.all([...materialIds].map(async materialId => {
        const matSnap = await getDoc(doc(db, "materials", materialId));
        if (matSnap.exists()) {
            materialPriceMap[materialId] = matSnap.data().unitPrice || 0;
        }
    }));
    
    // Calculate total cost
    snap.forEach(doc => {
        const d = doc.data();
        if (!d.reversed) {
            // Inventory items
            if (d.quantity && d.materialId) {
                const price = materialPriceMap[d.materialId] || 0;
                sum += Number(d.quantity) * Number(price);
            }
            // Supplier items
            else if (d.boughtFromSupplier && d.amount) {
                sum += Number(d.amount);
            }
            // Backward compatibility for supplier items without boughtFromSupplier flag
            else if (d.quantity && d.unitPrice && !d.materialId) {
                sum += Number(d.quantity) * Number(d.unitPrice);
            }
        }
    });
    
    return sum;
}

// New function to check if task is overdue
function checkTaskOverdue(task) {
    if (task.status === 'COMPLETED') return false;
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    if (task.giveTarget) {
        const targetDate = task.giveTarget.toDate ? task.giveTarget.toDate() : new Date(task.giveTarget);
        targetDate.setHours(0, 0, 0, 0);
        return targetDate < today;
    }
    
    if (task.endDate) {
        const endDate = task.endDate.toDate ? task.endDate.toDate() : new Date(task.endDate);
        endDate.setHours(0, 0, 0, 0);
        return endDate < today;
    }
    
    return false;
}

// Update parent task status if needed
async function updateParentTaskStatusIfNeeded(mainTaskId) {
    const mainTask = allTasks.find(t => t.id === mainTaskId);
    if (!mainTask) return;
    
    if (checkAllSubtasksCompleted(mainTask)) {
        if (mainTask.status !== 'COMPLETED') {
            await updateDoc(doc(db, "projectTasks", mainTaskId), { 
                status: 'COMPLETED',
                updatedAt: new Date()
            });
        }
    }
}

// Check if all subtasks are completed
function checkAllSubtasksCompleted(task) {
    if (!task.subTasks || task.subTasks.length === 0) {
        return task.status === 'COMPLETED';
    }
    
    for (const subTask of task.subTasks) {
        if (subTask.status !== 'COMPLETED') return false;
        
        if (subTask.subSubtasks && subTask.subSubtasks.length > 0) {
            for (const subSubTask of subTask.subSubtasks) {
                if (subSubTask.status !== 'COMPLETED') return false;
            }
        }
    }
    
    return true;
}

// Load all tasks with the new give target feature
async function loadAllTasks() {
    debugLog("Starting to load all tasks");
    
    try {
        if (unsubMain) {
            debugLog("Unsubscribing from previous listener");
            unsubMain();
        }
        
        if (subUnsubs) {
            debugLog("Unsubscribing from subtask listeners");
            Object.values(subUnsubs).forEach(fn => fn && fn());
        }
        
        subUnsubs = {};
        allTasks = [];
        
        debugLog("Setting up main tasks listener");
        unsubMain = onSnapshot(
            query(collection(db, "projectTasks"), where("projectId", "==", projectId)), 
            async (snapshot) => {
                debugLog("Main tasks snapshot received", snapshot.size);
                
                allTasks = [];
                let promises = [];
                
                if (snapshot.empty) {
                    debugLog("No main tasks found for project", projectId);
                    renderTasks([]);
                    renderGanttCalendar([]);
                    return;
                }
                
                snapshot.forEach(docSnap => {
                    const docData = { id: docSnap.id, ...docSnap.data(), subTasks: [] };
                    docData.expanded = expandedTasks[docSnap.id] || false;
                    
                    // Auto-categorize if no category is set
                    if (!docData.category && docData.taskDescription) {
                        docData.category = autoCategorizeTask(docData.taskDescription);
                    }
                    
                    // Check if task is overdue
                    if (checkTaskOverdue(docData)) {
                        docData.status = 'OVERDUE';
                    }
                    
                    allTasks.push(docData);
                    debugLog("Processing main task", docData.taskId);

                    promises.push(new Promise((resolve) => {
                        debugLog(`Setting up subtasks listener for ${docData.taskId}`);
                        const unsub = onSnapshot(
                            collection(db, "projectTasks", docSnap.id, "subtasks"), 
                            async (subSnap) => {
                                debugLog(`Subtasks snapshot for ${docData.taskId}`, subSnap.size);
                                
                                docData.subTasks = [];
                                let subPromises = [];
                                
                                subSnap.forEach(subDoc => {
                                    let subData = { id: subDoc.id, ...subDoc.data(), subSubtasks: [] };
                                    
                                    // Auto-categorize if no category is set
                                    if (!subData.category && subData.taskDescription) {
                                        subData.category = autoCategorizeTask(subData.taskDescription);
                                    }
                                    
                                    // Check if subtask is overdue
                                    if (checkTaskOverdue(subData)) {
                                        subData.status = 'OVERDUE';
                                    }
                                    
                                    docData.subTasks.push(subData);
                                    debugLog(`Processing subtask ${subData.taskId}`);
                                    
                                    // Get hours and material costs
                                    subPromises.push(Promise.all([
                                        getWorkedHoursForTaskId(subData.taskId),
                                        getMaterialCostForTaskId(subData.taskId)
                                    ]).then(([hours, materialCost]) => {
                                        subData._durationHours = hours;
                                        subData._materialCost = materialCost;
                                        debugLog(`Got hours/costs for ${subData.taskId}`, {hours, materialCost});
                                    }));
                                    
                                    // Get sub-subtasks
                                    subPromises.push(getSubSubtasks(docData.id, subDoc.id).then(subsubtasks => {
                                        subData.subSubtasks = subsubtasks;
                                        debugLog(`Got ${subsubtasks.length} sub-subtasks for ${subData.taskId}`);
                                        
                                        let subSubPromises = subsubtasks.map(subsub => {
                                            // Auto-categorize if no category is set
                                            if (!subsub.category && subsub.taskDescription) {
                                                subsub.category = autoCategorizeTask(subsub.taskDescription);
                                            }
                                            
                                            // Check if sub-subtask is overdue
                                            if (checkTaskOverdue(subsub)) {
                                                subsub.status = 'OVERDUE';
                                            }
                                            
                                            return Promise.all([
                                                getWorkedHoursForTaskId(subsub.taskId),
                                                getMaterialCostForTaskId(subsub.taskId)
                                            ]).then(([hours, materialCost]) => {
                                                subsub._durationHours = hours;
                                                subsub._materialCost = materialCost;
                                            });
                                        });
                                        return Promise.all(subSubPromises);
                                    }));
                                });
                                
                                await Promise.all(subPromises);
                                
                                // Check parent task status
                                if (docData.status !== 'COMPLETED' && checkAllSubtasksCompleted(docData)) {
                                    debugLog(`All subtasks completed for ${docData.taskId}, updating status`);
                                    await updateDoc(doc(db, "projectTasks", docData.id), { 
                                        status: 'COMPLETED',
                                        updatedAt: new Date()
                                    });
                                }
                                
                                resolve();
                            },
                            (error) => {
                                debugLog(`Error in subtasks listener for ${docData.taskId}`, error);
                                resolve();
                            }
                        );
                        subUnsubs[docSnap.id] = unsub;
                    }));
                });

                await Promise.all(promises);
                debugLog("All subtasks processed");

                // Get hours and material costs for all main tasks
                await Promise.all(allTasks.map(async (task) => {
                    const [hours, materialCost] = await Promise.all([
                        getWorkedHoursForTaskId(task.taskId),
                        getMaterialCostForTaskId(task.taskId)
                    ]);
                    task._durationHours = hours;
                    task._materialCost = materialCost;
                    debugLog(`Got main task hours/costs for ${task.taskId}`, {hours, materialCost});
                    
                    // Calculate aggregated values
                    if (task.subTasks && task.subTasks.length > 0) {
                        let totalHours = hours;
                        let totalMaterialCost = materialCost;
                        
                        task.subTasks.forEach(sub => {
                            totalHours += sub._durationHours || 0;
                            totalMaterialCost += sub._materialCost || 0;
                            
                            if (sub.subSubtasks && sub.subSubtasks.length > 0) {
                                sub.subSubtasks.forEach(subsub => {
                                    totalHours += subsub._durationHours || 0;
                                    totalMaterialCost += subsub._materialCost || 0;
                                });
                            }
                        });
                        
                        task._aggregatedDurationHours = totalHours;
                        task._aggregatedMaterialCost = totalMaterialCost;
                        debugLog(`Aggregated values for ${task.taskId}`, {totalHours, totalMaterialCost});
                    }
                }));

                debugLog("Rendering tasks and Gantt chart");
                renderTasks(filterTasks(allTasks));
                renderGanttCalendar(filterTasks(allTasks));
            },
            (error) => {
                debugLog("Error in main tasks listener", error);
                alert("Error loading tasks: " + error.message);
            }
        );
    } catch (e) {
        debugLog("Error in loadAllTasks", e);
        alert("Failed to load tasks: " + e.message);
    }
}

// Filter tasks with category support
function filterTasks(tasks) {
    const statusVal = statusFilter.value;
    const monthVal = monthFilter.value;
    const yearVal = yearFilter.value;
    const searchVal = searchInput.value.toLowerCase();
    
    return tasks.filter(task => {
        // Check hide completed filter
        if (hideCompleted && task.status === 'COMPLETED') {
            return false;
        }
        
        // Check category filter
        let matchesCategory = true;
        if (currentCategory) {
            if (currentCategory === 'general') {
                // General should show tasks with no category or general category
                matchesCategory = (!task.category || task.category === 'general');
            } else {
                matchesCategory = (task.category === currentCategory);
            }
        }
        
        // Check status filter
        let matchesStatus = true;
        if (statusVal) {
            if (statusVal.toUpperCase() === 'OVERDUE') {
                matchesStatus = checkTaskOverdue(task);
            } else {
                matchesStatus = (task.status && task.status.toUpperCase() === statusVal.toUpperCase());
            }
        }
        
        // Check month filter
        let matchesMonth = true;
        if (monthVal) {
            const monthNum = parseInt(monthVal);
            if (task.startDate) {
                const date = task.startDate.toDate ? task.startDate.toDate() : new Date(task.startDate);
                matchesMonth = date.getMonth() + 1 === monthNum;
            } else {
                matchesMonth = false;
            }
        }
        
        // Check year filter
        let matchesYear = true;
        if (yearVal) {
            const yearNum = parseInt(yearVal);
            if (task.startDate) {
                const date = task.startDate.toDate ? task.startDate.toDate() : new Date(task.startDate);
                matchesYear = date.getFullYear() === yearNum;
            } else {
                matchesYear = false;
            }
        }
        
        // Check search filter
        let matchesSearch = true;
        if (searchVal) {
            matchesSearch = (
                (task.taskId && task.taskId.toLowerCase().includes(searchVal)) ||
                (task.taskDescription && task.taskDescription.toLowerCase().includes(searchVal)) ||
                (task.assignedTo && task.assignedTo.toLowerCase().includes(searchVal)) ||
                (task.status && task.status.toLowerCase().includes(searchVal)) ||
                (task.location && task.location.toLowerCase().includes(searchVal)) ||
                (task.taskLine && task.taskLine.toString().includes(searchVal))
            );
            
            // Check subtasks if main task doesn't match
            if (!matchesSearch && task.subTasks) {
                for (const sub of task.subTasks) {
                    if (
                        (sub.taskId && sub.taskId.toLowerCase().includes(searchVal)) ||
                        (sub.taskDescription && sub.taskDescription.toLowerCase().includes(searchVal)) ||
                        (sub.assignedTo && sub.assignedTo.toLowerCase().includes(searchVal)) ||
                        (sub.status && sub.status.toLowerCase().includes(searchVal)) ||
                        (sub.location && sub.location.toLowerCase().includes(searchVal))
                    ) {
                        matchesSearch = true;
                        break;
                    }
                    
                    // Check sub-subtasks if subtask doesn't match
                    if (!matchesSearch && sub.subSubtasks) {
                        for (const subsub of sub.subSubtasks) {
                            if (
                                (subsub.taskId && subsub.taskId.toLowerCase().includes(searchVal)) ||
                                (subsub.taskDescription && subsub.taskDescription.toLowerCase().includes(searchVal)) ||
                                (subsub.assignedTo && subsub.assignedTo.toLowerCase().includes(searchVal)) ||
                                (subsub.status && subsub.status.toLowerCase().includes(searchVal)) ||
                                (subsub.location && subsub.location.toLowerCase().includes(searchVal))
                            ) {
                                matchesSearch = true;
                                break;
                            }
                        }
                    }
                    
                    if (matchesSearch) break;
                }
            }
        }
        
        return matchesCategory && matchesStatus && matchesMonth && matchesYear && matchesSearch;
    });
}

// Format give target display
function formatGiveTargetDisplay(giveTarget, status) {
    if (!giveTarget) return '';
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const targetDate = giveTarget.toDate ? giveTarget.toDate() : new Date(giveTarget);
    targetDate.setHours(0, 0, 0, 0);
    
    const formattedDate = formatDate(giveTarget);
    
    if (status === 'COMPLETED') {
        return `<span class="give-target-completed">${formattedDate}</span>`;
    } else if (targetDate < today) {
        return `<span class="give-target-overdue">${formattedDate} (Overdue)</span>`;
    } else if (status === 'ONGOING') {
        return `<span class="give-target-ongoing">${formattedDate}</span>`;
    } else {
        return `<span class="give-target-pending">${formattedDate}</span>`;
    }
}

// Make editable input for give target
function makeEditableInput(cell, type, field, inputType='text') {
    if (cell.querySelector('input')) return;
    const val = cell.textContent.trim();
    const input = document.createElement('input');
    input.type = inputType;
    if (inputType === 'date') {
        input.value = val ? formatDateForInput(val) : '';
    } else {
        input.value = val;
    }
    input.className = 'editable-input';
    input.setAttribute('data-field', field);

    if (field === 'taskDescription' || field === 'assignedTo') {
        input.style.textAlign = 'left';
    } else {
        input.style.textAlign = 'center';
    }

    cell.innerHTML = '';
    cell.appendChild(input);
    input.focus();
    input.onblur = async () => {
        let newValue = input.value;
        if (inputType === 'date' && newValue) newValue = new Date(newValue);
        await saveEditable(cell, type, field, newValue);
    };
    input.onkeypress = async (e) => {
        if (e.key === 'Enter') {
            input.blur();
        }
    };
}

// Make editable select for status
function makeEditableSelect(cell, type, field) {
    if (cell.querySelector('select')) return;
    const val = cell.textContent.trim();
    const select = document.createElement('select');
    select.className = 'editable-select';
    select.setAttribute('data-field', field);
    if (field === 'taskDescription' || field === 'assignedTo') {
        select.style.textAlign = 'left';
    } else {
        select.style.textAlign = 'center';
    }
    
    // Include OVERDUE in status options
    ['COMPLETED', 'ONGOING', 'PENDING', 'OVERDUE'].forEach(opt => {
        const o = document.createElement('option');
        o.value = opt;
        o.textContent = opt;
        if (val.toUpperCase() === opt) o.selected = true;
        select.appendChild(o);
    });
    
    cell.innerHTML = '';
    cell.appendChild(select);
    select.focus();
    select.onblur = async () => {
        await saveEditable(cell, type, field, select.value);
    };
    select.onchange = () => select.blur();
}

// Save editable fields including give target
async function saveEditable(cell, type, field, newVal) {
    const mainId = cell.dataset.mainid || cell.dataset.id;
    
    try {
        if (type === 'main') {
            const updateData = { [field]: newVal, updatedAt: new Date() };
            
            // If updating give target and task is overdue, update status
            if (field === 'giveTarget') {
                const task = allTasks.find(t => t.id === mainId);
                if (task && checkTaskOverdue({...task, giveTarget: newVal})) {
                    updateData.status = 'OVERDUE';
                }
            }
            
            await updateDoc(doc(db, "projectTasks", mainId), updateData);
            
            if (field === 'status' && newVal === 'COMPLETED') {
                await updateParentTaskStatusIfNeeded(mainId);
            }
        } else if (type === 'sub') {
            const updateData = { [field]: newVal, updatedAt: new Date() };
            
            // If updating give target and subtask is overdue, update status
            if (field === 'giveTarget') {
                const mainTask = allTasks.find(t => t.id === mainId);
                if (mainTask) {
                    const subtask = mainTask.subTasks.find(s => s.id === cell.dataset.id);
                    if (subtask && checkTaskOverdue({...subtask, giveTarget: newVal})) {
                        updateData.status = 'OVERDUE';
                    }
                }
            }
            
            await updateDoc(doc(db, "projectTasks", mainId, "subtasks", cell.dataset.id), updateData);
            
            if (field === 'status') {
                await updateParentTaskStatusIfNeeded(mainId);
            }
        } else if (type === 'subsub') {
            const updateData = { [field]: newVal, updatedAt: new Date() };
            
            // If updating give target and sub-subtask is overdue, update status
            if (field === 'giveTarget') {
                const mainTask = allTasks.find(t => t.id === cell.dataset.mainid);
                if (mainTask) {
                    const subtask = mainTask.subTasks.find(s => s.id === cell.dataset.subid);
                    if (subtask) {
                        const subsubtask = subtask.subSubtasks.find(ss => ss.id === cell.dataset.id);
                        if (subsubtask && checkTaskOverdue({...subsubtask, giveTarget: newVal})) {
                            updateData.status = 'OVERDUE';
                        }
                    }
                }
            }
            
            await updateDoc(doc(db, "projectTasks", cell.dataset.mainid, "subtasks", cell.dataset.subid, "subsubtasks", cell.dataset.id), updateData);
            
            if (field === 'status') {
                const subDoc = await getDoc(doc(db, "projectTasks", cell.dataset.mainid, "subtasks", cell.dataset.subid));
                if (subDoc.exists()) {
                    const subData = subDoc.data();
                    if (newVal === 'COMPLETED') {
                        const subSubtasks = await getSubSubtasks(cell.dataset.mainid, cell.dataset.subid);
                        const allCompleted = subSubtasks.every(s => s.status === 'COMPLETED');
                        
                        if (allCompleted && subData.status !== 'COMPLETED') {
                            await updateDoc(doc(db, "projectTasks", cell.dataset.mainid, "subtasks", cell.dataset.subid), { 
                                status: 'COMPLETED',
                                updatedAt: new Date()
                            });
                            
                            await updateParentTaskStatusIfNeeded(cell.dataset.mainid);
                        }
                    }
                }
            }
        }
    } catch (e) {
        alert("Error saving changes: " + e.message);
    }
}

// Delete task function
async function deleteTask(type, mainId, subId, subSubId) {
    if (!confirm("Are you sure you want to delete this task?")) return;
    
    try {
        if (type === 'main') {
            // Delete main task and all its subtasks
            await deleteDoc(doc(db, "projectTasks", mainId));
        } else if (type === 'sub') {
            // Delete subtask and all its sub-subtasks
            await deleteDoc(doc(db, "projectTasks", mainId, "subtasks", subId));
        } else if (type === 'subsub') {
            // Delete sub-subtask
            await deleteDoc(doc(db, "projectTasks", mainId, "subtasks", subId, "subsubtasks", subSubId));
        }
        alert("Task deleted successfully!");
    } catch (e) {
        alert("Error deleting task: " + e.message);
    }
}

// Format date for display
function formatDate(dateString) {
    if (!dateString) return '';
    const date = dateString.toDate ? dateString.toDate() : new Date(dateString);
    return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
}

// Format date for input field
function formatDateForInput(dateString) {
    if (!dateString) return '';
    const date = dateString.toDate ? dateString.toDate() : new Date(dateString);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Format currency
function formatCurrency(amount, curr='ZMW') {
    if (!amount && amount !== 0) return '';
    const formatter = new Intl.NumberFormat(undefined, {
        style: 'currency',
        currency: curr || 'ZMW',
        minimumFractionDigits: 2
    });
    return formatter.format(amount);
}

// Get status badge class
function getStatusBadge(status) {
    if (!status) return '';
    status = status.toUpperCase();
    if (status === 'COMPLETED') return 'status-badge status-completed';
    if (status === 'ONGOING') return 'status-badge status-ongoing';
    if (status === 'OVERDUE') return 'status-badge status-overdue';
    return 'status-badge status-pending';
}

// Get sub-subtasks
async function getSubSubtasks(mainId, subId) {
    const snap = await getDocs(collection(db, "projectTasks", mainId, "subtasks", subId, "subsubtasks"));
    let subsubtasks = [];
    snap.forEach(subSubDoc => {
        subsubtasks.push({ id: subSubDoc.id, ...subSubDoc.data() });
    });
    return subsubtasks;
}

// Get category display name
function getCategoryDisplayName(categoryId) {
    return categories[categoryId] ? categories[categoryId].name : 'General';
}

// Get category icon
function getCategoryIcon(categoryId) {
    return categories[categoryId] ? categories[categoryId].icon : 'fas fa-tools';
}

// Show category transfer modal
function showCategoryTransferModal(task, type, mainId, subId = null) {
    selectedTaskForTransfer = { task, type, mainId, subId };
    selectedCategoryForTransfer = null;
    
    // Update modal content
    transferTaskInfo.innerHTML = `
        <p><strong>Task ID:</strong> ${task.taskId}</p>
        <p><strong>Description:</strong> ${task.taskDescription}</p>
        <p><strong>Current Category:</strong> ${getCategoryDisplayName(task.category || 'general')}</p>
    `;
    
    // Populate category options
    categoryOptions.innerHTML = '';
    for (const [categoryId, category] of Object.entries(categories)) {
        // Skip the current category
        if (categoryId === (task.category || 'general')) continue;
        
        const option = document.createElement('div');
        option.className = 'category-option';
        option.dataset.categoryId = categoryId;
        option.innerHTML = `
            <i class="${category.icon} category-option-icon" style="color: ${category.color}"></i>
            <span class="category-option-name">${category.name}</span>
        `;
        option.onclick = () => selectCategory(categoryId, option);
        categoryOptions.appendChild(option);
    }
    
    // Reset transfer button
    confirmTransferBtn.disabled = true;
    confirmTransferBtn.textContent = 'Transfer Task';
    
    // Show modal
    categoryTransferModal.style.display = 'flex';
}

// Select category for transfer
function selectCategory(categoryId, optionElement) {
    // Remove selected class from all options
    document.querySelectorAll('.category-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    
    // Add selected class to clicked option
    optionElement.classList.add('selected');
    
    // Update selected category
    selectedCategoryForTransfer = categoryId;
    
    // Enable transfer button
    confirmTransferBtn.disabled = false;
}

// Transfer task to new category
async function transferTaskToCategory() {
    if (!selectedTaskForTransfer || !selectedCategoryForTransfer) return;
    
    const { task, type, mainId, subId } = selectedTaskForTransfer;
    
    try {
        let updateData = { 
            category: selectedCategoryForTransfer,
            updatedAt: new Date()
        };
        
        if (type === 'main') {
            await updateDoc(doc(db, "projectTasks", mainId), updateData);
        } else if (type === 'sub') {
            await updateDoc(doc(db, "projectTasks", mainId, "subtasks", subId), updateData);
        } else if (type === 'subsub') {
            await updateDoc(doc(db, "projectTasks", mainId, "subtasks", subId, "subsubtasks", task.id), updateData);
        }
        
        alert(`Task transferred to ${getCategoryDisplayName(selectedCategoryForTransfer)} successfully!`);
        closeCategoryTransferModal();
        
        // If we're in a category view and the task no longer matches, reload tasks
        if (currentCategory && selectedCategoryForTransfer !== currentCategory) {
            loadAllTasks();
        }
    } catch (e) {
        alert("Error transferring task: " + e.message);
    }
}

// Close category transfer modal
function closeCategoryTransferModal() {
    categoryTransferModal.style.display = 'none';
    selectedTaskForTransfer = null;
    selectedCategoryForTransfer = null;
}

// Show status dropdown menu
function showStatusDropdown(cell, type, taskId, mainId, subId = null) {
    // Close any existing dropdown
    if (activeStatusDropdown) {
        activeStatusDropdown.remove();
        activeStatusDropdown = null;
    }
    
    const currentStatus = cell.textContent.trim();
    
    // Create dropdown
    const dropdown = document.createElement('div');
    dropdown.className = 'status-dropdown-content show';
    dropdown.style.position = 'absolute';
    dropdown.style.left = '0';
    dropdown.style.top = '100%';
    dropdown.style.zIndex = '1000';
    
    // Status options
    const statusOptions = [
        { value: 'COMPLETED', label: 'Completed', icon: 'fas fa-check-circle', color: '#10b981' },
        { value: 'ONGOING', label: 'Ongoing', icon: 'fas fa-sync-alt', color: '#3b82f6' },
        { value: 'PENDING', label: 'Pending', icon: 'fas fa-clock', color: '#6b7280' },
        { value: 'OVERDUE', label: 'Overdue', icon: 'fas fa-exclamation-triangle', color: '#ef4444' }
    ];
    
    // Add status options to dropdown
    statusOptions.forEach(option => {
        const statusOption = document.createElement('div');
        statusOption.className = 'status-option';
        if (option.value === currentStatus) {
            statusOption.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
        }
        statusOption.innerHTML = `
            <i class="${option.icon}" style="color: ${option.color}"></i>
            <span>${option.label}</span>
        `;
        statusOption.onclick = async () => {
            await saveEditable(cell, type, 'status', option.value);
            dropdown.remove();
            activeStatusDropdown = null;
        };
        dropdown.appendChild(statusOption);
    });
    
    // Add hide completed option if current status is COMPLETED
    if (currentStatus === 'COMPLETED') {
        const hideOption = document.createElement('div');
        hideOption.className = 'status-option hide-option';
        hideOption.innerHTML = `
            <i class="fas fa-eye-slash" style="color: #6b7280"></i>
            <span>Hide This Task</span>
        `;
        hideOption.onclick = () => {
            hideCompleted = true;
            saveFilterStates();
            renderTasks(filterTasks(allTasks));
            dropdown.remove();
            activeStatusDropdown = null;
        };
        dropdown.appendChild(hideOption);
    }
    
    // Position dropdown
    const rect = cell.getBoundingClientRect();
    dropdown.style.left = '0';
    dropdown.style.top = '100%';
    dropdown.style.minWidth = rect.width + 'px';
    
    cell.appendChild(dropdown);
    activeStatusDropdown = dropdown;
    
    // Close dropdown when clicking outside
    setTimeout(() => {
        const closeDropdown = (e) => {
            if (!cell.contains(e.target)) {
                dropdown.remove();
                activeStatusDropdown = null;
                document.removeEventListener('click', closeDropdown);
            }
        };
        document.addEventListener('click', closeDropdown);
    }, 0);
}

// Render tasks with the new give target column and category transfer button
function renderTasks(tasks) {
    taskList.innerHTML = '';
    let visibleCount = 0;
    tasks.sort((a, b) => (a.taskLine || 0) - (b.taskLine || 0));
    
    // Calculate totals
    let totalDuration = 0;
    let totalMaterialCost = 0;
    let totalManCost = 0;
    let totalCost = 0;
    
    tasks.forEach(task => {
        visibleCount++;
        const hours = task._durationHours || 0;
        const materialCost = task._materialCost || 0;
        const manCost = hours * 20;
        const taskTotalCost = manCost + materialCost;
        
        const displayHours = task._aggregatedDurationHours !== undefined ? task._aggregatedDurationHours : hours;
        const displayMaterialCost = task._aggregatedMaterialCost !== undefined ? task._aggregatedMaterialCost : materialCost;
        const displayManCost = displayHours * 20;
        const displayTotalCost = displayManCost + displayMaterialCost;
        
        // Add to totals
        totalDuration += displayHours;
        totalMaterialCost += displayMaterialCost;
        totalManCost += displayManCost;
        totalCost += displayTotalCost;
        
        const tr = document.createElement('tr');
        tr.classList.add('main-task-row');
        tr.innerHTML = `
            <td>
                <span class="main-task-expand" data-id="${task.id}" style="font-size:17px">
                    <i class="fas fa-${task.expanded ? "caret-down" : "caret-right"}"></i>
                </span>
            </td>
            <td data-id="${task.id}">${task.taskId || ''}</td>
            <td class="editable" data-type="main" data-field="taskLine" data-id="${task.id}">${task.taskLine || ''}</td>
            <td class="editable" data-type="main" data-field="taskDescription" data-id="${task.id}">${task.taskDescription || ''}</td>
            <td class="editable" data-type="main" data-field="assignedTo" data-id="${task.id}">${task.assignedTo || ''}</td>
            <td class="status-dropdown editable" data-type="main" data-field="status" data-id="${task.id}">
                <span class="${getStatusBadge(task.status)}">${task.status || ''}</span>
            </td>
            <td class="editable" data-type="main" data-field="startDate" data-id="${task.id}">${formatDate(task.startDate) || ''}</td>
            <td class="editable" data-type="main" data-field="endDate" data-id="${task.id}">${formatDate(task.endDate) || ''}</td>
            <td class="editable give-target-cell" data-type="main" data-field="giveTarget" data-id="${task.id}">
                ${formatGiveTargetDisplay(task.giveTarget, task.status)}
            </td>
            <td>${displayHours}</td>
            <td><span class="cost-badge">${formatCurrency(displayMaterialCost)}</span></td>
            <td><span class="cost-badge">${formatCurrency(displayManCost)}</span></td>
            <td><span class="cost-badge">${formatCurrency(displayTotalCost)}</span></td>
            <td>${task.location || ''}</td>
            <td>${getCategoryDisplayName(task.category || 'general')}</td>
            <td>
                <button class="add-subtask-btn action-btn" data-mainid="${task.id}">
                    <i class="fas fa-plus"></i> Subtask
                </button>
                <button class="transfer-task-btn" onclick="showCategoryTransferModal(${JSON.stringify(task).replace(/"/g, '&quot;')}, 'main', '${task.id}')">
                    <i class="fas fa-exchange-alt"></i> Transfer
                </button>
                <button class="delete-btn" onclick="deleteTask('main', '${task.id}')">
                    <i class="fas fa-trash"></i>
                </button>
            </td>
        `;
        taskList.appendChild(tr);

        if (task.expanded) {
            if (!task.subTasks || !task.subTasks.length) {
                const trSub = document.createElement('tr');
                trSub.classList.add('subtask-row');
                trSub.innerHTML = `<td></td><td colspan="15">No sub tasks yet.</td>`;
                taskList.appendChild(trSub);
            } else {
                task.subTasks.forEach(sub => {
                    const subHours = sub._durationHours || 0;
                    const subMaterialCost = sub._materialCost || 0;
                    const subManCost = subHours * 20;
                    const subTotalCost = subManCost + subMaterialCost;
                    
                    // Add to totals
                    totalDuration += subHours;
                    totalMaterialCost += subMaterialCost;
                    totalManCost += subManCost;
                    totalCost += subTotalCost;
                    
                    const trSub = document.createElement('tr');
                    trSub.classList.add('subtask-row');
                    trSub.innerHTML = `
                        <td class="subtask-arrow"></td>
                        <td data-mainid="${task.id}" data-id="${sub.id}">${sub.taskId || ''}</td>
                        <td></td>
                        <td class="editable subtask-desc" data-type="sub" data-mainid="${task.id}" data-field="taskDescription" data-id="${sub.id}">${sub.taskDescription || ''}</td>
                        <td class="editable" data-type="sub" data-mainid="${task.id}" data-field="assignedTo" data-id="${sub.id}">${sub.assignedTo || ''}</td>
                        <td class="status-dropdown editable" data-type="sub" data-mainid="${task.id}" data-field="status" data-id="${sub.id}">
                            <span class="${getStatusBadge(sub.status)}">${sub.status || ''}</span>
                        </td>
                        <td class="editable" data-type="sub" data-mainid="${task.id}" data-field="startDate" data-id="${sub.id}">${formatDate(sub.startDate) || ''}</td>
                        <td class="editable" data-type="sub" data-mainid="${task.id}" data-field="endDate" data-id="${sub.id}">${formatDate(sub.endDate) || ''}</td>
                        <td class="editable give-target-cell" data-type="sub" data-mainid="${task.id}" data-field="giveTarget" data-id="${sub.id}">
                            ${formatGiveTargetDisplay(sub.giveTarget, sub.status)}
                        </td>
                        <td>${subHours}</td>
                        <td><span class="cost-badge">${formatCurrency(subMaterialCost)}</span></td>
                        <td><span class="cost-badge">${formatCurrency(subManCost)}</span></td>
                        <td><span class="cost-badge">${formatCurrency(subTotalCost)}</span></td>
                        <td>${sub.location || ''}</td>
                        <td>${getCategoryDisplayName(sub.category || 'general')}</td>
                        <td>
                            <button class="add-subsubtask-btn action-btn" data-mainid="${task.id}" data-subid="${sub.id}">
                                <i class="fas fa-plus"></i> Sub-Subtask
                            </button>
                            <button class="transfer-task-btn" onclick="showCategoryTransferModal(${JSON.stringify(sub).replace(/"/g, '&quot;')}, 'sub', '${task.id}', '${sub.id}')">
                                <i class="fas fa-exchange-alt"></i> Transfer
                            </button>
                            <button class="delete-btn" onclick="deleteTask('sub', '${task.id}', '${sub.id}')">
                                <i class="fas fa-trash"></i>
                            </button>
                        </td>
                    `;
                    taskList.appendChild(trSub);

                    if (sub.subSubtasks && sub.subSubtasks.length) {
                        sub.subSubtasks.forEach(subsub => {
                            const subsubHours = subsub._durationHours || 0;
                            const subsubMaterialCost = subsub._materialCost || 0;
                            const subsubManCost = subsubHours * 20;
                            const subsubTotalCost = subsubManCost + subsubMaterialCost;
                            
                            // Add to totals
                            totalDuration += subsubHours;
                            totalMaterialCost += subsubMaterialCost;
                            totalManCost += subsubManCost;
                            totalCost += subsubTotalCost;
                            
                            const trSubSub = document.createElement('tr');
                            trSubSub.classList.add('subsubtask-row');
                            trSubSub.innerHTML = `
                                <td class="subtask-arrow"></td>
                                <td data-mainid="${task.id}" data-subid="${sub.id}" data-id="${subsub.id}">${subsub.taskId || ''}</td>
                                <td></td>
                                <td class="editable subtask-desc" style="padding-left:40px" data-type="subsub" data-mainid="${task.id}" data-subid="${sub.id}" data-field="taskDescription" data-id="${subsub.id}">${subsub.taskDescription || ''}</td>
                                <td class="editable" data-type="subsub" data-mainid="${task.id}" data-subid="${sub.id}" data-field="assignedTo" data-id="${subsub.id}">${subsub.assignedTo || ''}</td>
                                <td class="status-dropdown editable" data-type="subsub" data-mainid="${task.id}" data-subid="${sub.id}" data-field="status" data-id="${subsub.id}">
                                    <span class="${getStatusBadge(subsub.status)}">${subsub.status || ''}</span>
                                </td>
                                <td class="editable" data-type="subsub" data-mainid="${task.id}" data-subid="${sub.id}" data-field="startDate" data-id="${subsub.id}">${formatDate(subsub.startDate) || ''}</td>
                                <td class="editable" data-type="subsub" data-mainid="${task.id}" data-subid="${sub.id}" data-field="endDate" data-id="${subsub.id}">${formatDate(subsub.endDate) || ''}</td>
                                <td class="editable give-target-cell" data-type="subsub" data-mainid="${task.id}" data-subid="${sub.id}" data-field="giveTarget" data-id="${subsub.id}">
                                    ${formatGiveTargetDisplay(subsub.giveTarget, subsub.status)}
                                </td>
                                <td>${subsubHours}</td>
                                <td><span class="cost-badge">${formatCurrency(subsubMaterialCost)}</span></td>
                                <td><span class="cost-badge">${formatCurrency(subsubManCost)}</span></td>
                                <td><span class="cost-badge">${formatCurrency(subsubTotalCost)}</span></td>
                                <td>${subsub.location || ''}</td>
                                <td>${getCategoryDisplayName(subsub.category || 'general')}</td>
                                <td>
                                    <button class="transfer-task-btn" onclick="showCategoryTransferModal(${JSON.stringify(subsub).replace(/"/g, '&quot;')}, 'subsub', '${task.id}', '${sub.id}')">
                                        <i class="fas fa-exchange-alt"></i> Transfer
                                    </button>
                                    <button class="delete-btn" onclick="deleteTask('subsub', '${task.id}', '${sub.id}', '${subsub.id}')">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </td>
                            `;
                            taskList.appendChild(trSubSub);
                        });
                    }
                });
            }
        }
    });

    // Update totals row
    document.getElementById('totalDuration').textContent = totalDuration;
    document.getElementById('totalMaterialCost').textContent = formatCurrency(totalMaterialCost);
    document.getElementById('totalManCost').textContent = formatCurrency(totalManCost);
    document.getElementById('totalCost').textContent = formatCurrency(totalCost);

    emptyState.style.display = visibleCount === 0 ? 'block' : 'none';

    document.querySelectorAll('.main-task-expand').forEach(btn => {
        btn.onclick = () => {
            const mainId = btn.dataset.id;
            expandedTasks[mainId] = !expandedTasks[mainId];
            saveExpandedTasks();
            allTasks.find(t => t.id === mainId).expanded = expandedTasks[mainId];
            renderTasks(filterTasks(allTasks));
            renderGanttCalendar(filterTasks(allTasks));
        };
    });

    document.querySelectorAll('.add-subtask-btn').forEach(btn => {
        btn.classList.add("action-btn");
        btn.onclick = () => {
            const mainId = btn.dataset.mainid;
            addSubtask(mainId);
        };
    });
    
    document.querySelectorAll('.add-subsubtask-btn').forEach(btn => {
        btn.classList.add("action-btn");
        btn.onclick = () => {
            const mainId = btn.dataset.mainid;
            const subId = btn.dataset.subid;
            addSubSubtask(mainId, subId);
        };
    });
    
    // Add event listeners for status dropdowns
    document.querySelectorAll('.status-dropdown').forEach(cell => {
        cell.onclick = function(e) {
            e.stopPropagation();
            const type = this.dataset.type;
            const taskId = this.dataset.id;
            const mainId = this.dataset.mainid;
            const subId = this.dataset.subid;
            showStatusDropdown(this, type, taskId, mainId, subId);
        };
    });
    
    // Add event listeners for other editable fields
    document.querySelectorAll('.editable:not(.status-dropdown)').forEach(cell => {
        cell.onclick = function() {
            const type = this.dataset.type;
            const field = this.dataset.field;
            if (field === 'startDate' || field === 'endDate' || field === 'giveTarget') {
                makeEditableInput(this, type, field, 'date');
            } else if (field === 'taskLine') {
                makeEditableInput(this, type, field, 'number');
            } else {
                makeEditableInput(this, type, field);
            }
        };
    });
}

// Add task with start date and give target
addTaskBtn.onclick = async () => {
    const projectName = await getProjectName(projectId);
    const initials = getInitials(projectName);
    const nextNum = await getNextMainTaskNumber(projectId);
    const taskId = `${initials}-${nextNum}`;
    const taskDesc = prompt("Main Task Description:");
    if (!taskDesc) return;
    const assignedTo = prompt("Assigned To:");
    const location = prompt("Location:");
    const taskLine = parseInt(prompt("Task Line (number, optional):") || 0);
    
    // Auto-categorize the task
    const category = autoCategorizeTask(taskDesc);
    
    // Get start date
    const startDate = prompt("Start Date (YYYY-MM-DD, required):");
    if (!startDate) {
        alert("Start date is required!");
        return;
    }
    
    // Get give target (optional)
    const giveTarget = prompt("Give Target Date (YYYY-MM-DD, optional):");
    
    try {
        await addDoc(collection(db, "projectTasks"), {
            projectId,
            taskId,
            taskLine,
            taskDescription: taskDesc,
            assignedTo,
            location,
            category: category,
            status: "PENDING",
            startDate: new Date(startDate),
            giveTarget: giveTarget ? new Date(giveTarget) : null,
            createdAt: new Date(),
            updatedAt: new Date()
        });
        alert('Main task added! Category: ' + categories[category].name);
    } catch (e) {
        alert("Error adding main task: " + e.message);
    }
};

// Add subtask with give target
async function addSubtask(mainId) {
    const mainDoc = await getDoc(doc(db, "projectTasks", mainId));
    if (!mainDoc.exists()) return alert("Main task not found!");
    const mainTaskId = mainDoc.data().taskId;
    const nextNum = await getNextSubtaskNumber(mainTaskId, mainId);
    const subTaskId = `${mainTaskId}-${nextNum}`;
    const taskDesc = prompt("Sub Task Description:");
    if (!taskDesc) return;
    const assignedTo = prompt("Assigned To:");
    const location = prompt("Location:");
    const status = prompt("Status (COMPLETED, ONGOING, PENDING):", "PENDING") || "PENDING";
    const startDate = prompt("Start Date (YYYY-MM-DD):");
    const endDate = prompt("End Date (YYYY-MM-DD):");
    const giveTarget = prompt("Give Target Date (YYYY-MM-DD, optional):");
    const duration = parseFloat(prompt("Duration (number, hour, optional):") || 0);
    
    // Auto-categorize the subtask
    const category = autoCategorizeTask(taskDesc);
    
    try {
        await addDoc(collection(db, "projectTasks", mainId, "subtasks"), {
            taskId: subTaskId,
            taskDescription: taskDesc,
            assignedTo,
            location,
            category: category,
            status: status.toUpperCase(),
            startDate: startDate ? new Date(startDate) : null,
            endDate: endDate ? new Date(endDate) : null,
            giveTarget: giveTarget ? new Date(giveTarget) : null,
            duration,
            createdAt: new Date(),
            updatedAt: new Date()
        });
    } catch (e) {
        alert("Error adding sub task: " + e.message);
    }
}

// Add sub-subtask with give target
async function addSubSubtask(mainId, subtaskId) {
    const subDoc = await getDoc(doc(db, "projectTasks", mainId, "subtasks", subtaskId));
    if (!subDoc.exists()) return alert("Subtask not found!");
    const subTaskId = subDoc.data().taskId;
    const nextNum = await getNextSubSubtaskNumber(subTaskId, mainId, subtaskId);
    const subSubTaskId = `${subTaskId}-${nextNum}`;
    const taskDesc = prompt("Sub-Subtask Description:");
    if (!taskDesc) return;
    const assignedTo = prompt("Assigned To:");
    const location = prompt("Location:");
    const status = prompt("Status (COMPLETED, ONGOING, PENDING):", "PENDING") || "PENDING";
    const startDate = prompt("Start Date (YYYY-MM-DD):");
    const endDate = prompt("End Date (YYYY-MM-DD):");
    const giveTarget = prompt("Give Target Date (YYYY-MM-DD, optional):");
    const duration = parseFloat(prompt("Duration (number, hour, optional):") || 0);
    
    // Auto-categorize the sub-subtask
    const category = autoCategorizeTask(taskDesc);
    
    try {
        await addDoc(collection(db, "projectTasks", mainId, "subtasks", subtaskId, "subsubtasks"), {
            taskId: subSubTaskId,
            taskDescription: taskDesc,
            assignedTo,
            location,
            category: category,
            status: status.toUpperCase(),
            startDate: startDate ? new Date(startDate) : null,
            endDate: endDate ? new Date(endDate) : null,
            giveTarget: giveTarget ? new Date(giveTarget) : null,
            duration,
            createdAt: new Date(),
            updatedAt: new Date()
        });
        alert('Sub-subtask added! Category: ' + categories[category].name);
    } catch (e) {
        alert("Error adding sub-subtask: " + e.message);
    }
}

// Gantt chart functions
function buildGanttCalendarHeaders(baseYear, showCurrentMonthOnly) {
    const months = [
        {name: "Jan", days: 31},{name:"Feb",days:28},{name:"Mar",days:31},{name:"Apr",days:30},
        {name:"May",days:31},{name:"Jun",days:30},{name:"Jul",days:31},{name:"Aug",days:31},
        {name:"Sep",days:30},{name:"Oct",days:31},{name:"Nov",days:30},{name:"Dec",days:31}
    ];
    
    if ((baseYear % 4 === 0 && baseYear % 100 !== 0) || baseYear % 400 === 0) {
        months[1].days = 29;
    }
    
    const today = new Date();
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
    
    let row1 = `<tr><th rowspan="3" style="min-width:160px;text-align:left;">TASK</th>`;
    let row2 = "<tr>";
    let row3 = "<tr>";
    
    for (let m = 0; m < months.length; m++) {
        const month = months[m];
        const monthClass = (showCurrentMonthOnly && m === currentMonth && baseYear === currentYear) ? "current-month" : "";
        
        if (!showCurrentMonthOnly || (m === currentMonth && baseYear === currentYear)) {
            row1 += `<th colspan="${month.days}" class="${monthClass}">${month.name}</th>`;
            
            for(let d=1; d<=month.days; d++) {
                const dt = new Date(baseYear, m, d);
                const wd = ["S","M","T","W","R","F","S"][dt.getDay()];
                const isToday = dt.getDate() === today.getDate() && 
                                dt.getMonth() === today.getMonth() && 
                                dt.getFullYear() === today.getFullYear();
                const dayClass = isToday ? "today-highlight" : "";
                
                row2 += `<th class="${dayClass}">${d}</th>`;
                row3 += `<th class="${dayClass}">${wd}</th>`;
            }
        }
    }
    
    row1 += "</tr>";
    row2 += "</tr>";
    row3 += "</tr>";
    
    ganttCalendarHead.innerHTML = row1 + row2 + row3;
    return {months};
}

function renderGanttCalendar(tasks) {
    let allRows = [];
    let minYear = new Date().getFullYear();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    tasks.forEach(main => {
        allRows.push({
            isSub: false,
            description: main.taskDescription || '',
            status: main.status,
            startDate: main.startDate,
            endDate: main.endDate,
            giveTarget: main.giveTarget
        });
        
        if (main.startDate) {
            const y = (main.startDate?.toDate ? main.startDate.toDate() : new Date(main.startDate)).getFullYear();
            if (y < minYear) minYear = y;
        }
        
        (main.subTasks || []).forEach(sub => {
            allRows.push({
                isSub: true,
                description: sub.taskDescription || '',
                status: sub.status,
                startDate: sub.startDate,
                endDate: sub.endDate,
                giveTarget: sub.giveTarget
            });
            
            if (sub.startDate) {
                const y = (sub.startDate?.toDate ? sub.startDate.toDate() : new Date(sub.startDate)).getFullYear();
                if (y < minYear) minYear = y;
            }
            
            (sub.subSubtasks || []).forEach(subsub => {
                allRows.push({
                    isSubSub: true,
                    description: subsub.taskDescription || '',
                    status: subsub.status,
                    startDate: subsub.startDate,
                    endDate: subsub.endDate,
                    giveTarget: subsub.giveTarget
                });
                
                if (subsub.startDate) {
                    const y = (subsub.startDate?.toDate ? subsub.startDate.toDate() : new Date(subsub.startDate)).getFullYear();
                    if (y < minYear) minYear = y;
                }
            });
        });
    });
    
    const { months } = buildGanttCalendarHeaders(minYear, showCurrentMonthOnly);
    ganttCalendarBody.innerHTML = "";
    
    allRows.forEach(rowTask => {
        let pct = "";
        if (rowTask.status && rowTask.status.toUpperCase() === "COMPLETED") pct = "100%";
        else if (rowTask.status && rowTask.status.toUpperCase() === "ONGOING") pct = "60%";
        else if (rowTask.status && rowTask.status.toUpperCase() === "PENDING") pct = "0%";
        else if (rowTask.status && rowTask.status.toUpperCase() === "OVERDUE") pct = "0%";
        else pct = "";
        
        let desc = rowTask.isSubSub
            ? '<span style="margin-left:32px;color:#64748b;font-size:12px;vertical-align:middle;"></span> <span style="opacity:.8;">' + rowTask.description + '</span>'
            : rowTask.isSub
            ? '<span style="margin-left:12px;color:#3b82f6;font-size:13px;vertical-align:middle;"></span> <span style="opacity:.8;">' + rowTask.description + '</span>'
            : '<span style="font-weight:bold;color:#3b82f6;">' + rowTask.description + '</span>';
        
        let row = `<tr><td style="text-align:left">${desc}</td>`;
        let start = null, end = null;
        
        // Use giveTarget if available, otherwise use startDate/endDate
        if (rowTask.giveTarget) {
            start = rowTask.giveTarget.toDate ? rowTask.giveTarget.toDate() : new Date(rowTask.giveTarget);
            start = new Date(start.getFullYear(), start.getMonth(), start.getDate());
            
            if (rowTask.status === 'ONGOING' || rowTask.status === 'PENDING' || rowTask.status === 'OVERDUE') {
                end = today;
            }
        } else if (rowTask.startDate) {
            start = rowTask.startDate.toDate ? rowTask.startDate.toDate() : new Date(rowTask.startDate);
            start = new Date(start.getFullYear(), start.getMonth(), start.getDate());
            
            if ((rowTask.status === 'ONGOING' || rowTask.status === 'PENDING' || rowTask.status === 'OVERDUE') && !rowTask.endDate) {
                end = today;
            } else if (rowTask.endDate) {
                end = rowTask.endDate.toDate ? rowTask.endDate.toDate() : new Date(rowTask.endDate);
                end = new Date(end.getFullYear(), end.getMonth(), end.getDate());
            }
        }
        
        let colDate = new Date(minYear, 0, 1);
        const currentMonth = today.getMonth();
        const currentYear = today.getFullYear();
        
        for (let m = 0; m < months.length; m++) {
            const month = months[m];
            
            if (showCurrentMonthOnly && (m !== currentMonth || minYear !== currentYear)) {
                colDate.setMonth(colDate.getMonth() + 1);
                colDate.setDate(1);
                continue;
            }
            
            for (let d = 1; d <= month.days; d++) {
                let bar = '';
                
                if (start) {
                    let testDate = new Date(colDate.getFullYear(), colDate.getMonth(), colDate.getDate());
                    
                    if (testDate >= start && (!end || testDate <= end)) {
                        const isToday = testDate.getTime() === today.getTime();
                        const isPast = testDate < today;
                        
                        if (!rowTask.isSub && !rowTask.isSubSub) {
                            if (pct === "100%") {
                                bar = '<div class="gantt-bar"></div>';
                            } else if (pct === "60%") {
                                if (isToday) {
                                    bar = '<div class="gantt-bar" style="background:#f59e0b"></div>';
                                } else if (isPast) {
                                    bar = '<div class="gantt-bar" style="background:#fcd34d"></div>';
                                } else {
                                    bar = '<div class="gantt-bar" style="background:#fcd34d;opacity:0.6"></div>';
                                }
                            } else {
                                if (isToday) {
                                    bar = '<div class="gantt-bar" style="background:#f59e0b"></div>';
                                } else if (isPast) {
                                    bar = '<div class="gantt-bar gantt-bar-empty"></div>';
                                } else {
                                    bar = '<div class="gantt-bar gantt-bar-empty" style="opacity:0.6"></div>';
                                }
                            }
                        } else if (rowTask.isSub) {
                            if (pct === "100%") {
                                bar = '<div class="gantt-bar" style="background:#3b82f6;opacity:.6"></div>';
                            } else if (pct === "60%") {
                                if (isToday) {
                                    bar = '<div class="gantt-bar" style="background:#2563eb"></div>';
                                } else if (isPast) {
                                    bar = '<div class="gantt-bar" style="background:#93c5fd"></div>';
                                } else {
                                    bar = '<div class="gantt-bar" style="background:#93c5fd;opacity:0.6"></div>';
                                }
                            } else {
                                if (isToday) {
                                    bar = '<div class="gantt-bar" style="background:#2563eb"></div>';
                                } else if (isPast) {
                                    bar = '<div class="gantt-bar gantt-bar-empty"></div>';
                                } else {
                                    bar = '<div class="gantt-bar gantt-bar-empty" style="opacity:0.6"></div>';
                                }
                            }
                        } else if (rowTask.isSubSub) {
                                if (pct === "100%") {
                                    bar = '<div class="gantt-bar" style="background:#64748b;opacity:.6"></div>';
                                } else if (pct === "60%") {
                                    if (isToday) {
                                        bar = '<div class="gantt-bar" style="background:#475569"></div>';
                                    } else if (isPast) {
                                        bar = '<div class="gantt-bar" style="background:#94a3b8"></div>';
                                    } else {
                                        bar = '<div class="gantt-bar" style="background:#94a3b8;opacity:0.6"></div>';
                                    }
                                } else {
                                    if (isToday) {
                                        bar = '<div class="gantt-bar" style="background:#475569"></div>';
                                    } else if (isPast) {
                                        bar = '<div class="gantt-bar gantt-bar-empty"></div>';
                                    } else {
                                        bar = '<div class="gantt-bar gantt-bar-empty" style="opacity:0.6"></div>';
                                    }
                                }
                            }
                        }
                    }
                    
                    row += `<td>${bar}</td>`;
                    colDate.setDate(colDate.getDate() + 1);
                }
            }
            
            row += `</tr>`;
            ganttCalendarBody.innerHTML += row;
        });
    }

    // Toggle Gantt visibility
    function toggleGanttVisibility() {
        ganttVisible = !ganttVisible;
        if (ganttVisible) {
            ganttTableCard.classList.remove('hide');
            showGanttBtn.classList.add('hide');
            mainCard.style.flexBasis = '65%';
            ganttTableCard.style.flexBasis = '35%';
            localStorage.setItem('ganttVisible', 'true');
        } else {
            ganttTableCard.classList.add('hide');
            showGanttBtn.classList.remove('hide');
            mainCard.style.flexBasis = '100%';
            localStorage.setItem('ganttVisible', 'false');
        }
    }

    // Toggle current month view
    function toggleCurrentMonthView() {
        showCurrentMonthOnly = !showCurrentMonthOnly;
        currentMonthBtn.textContent = showCurrentMonthOnly ? "All Months" : "Current Month";
        localStorage.setItem('showCurrentMonthOnly', showCurrentMonthOnly.toString());
        renderGanttCalendar(filterTasks(allTasks));
    }

    // Toggle fullscreen
    function toggleFullscreen() {
        if (!isFullscreen) {
            if (ganttTableCard.requestFullscreen) {
                ganttTableCard.requestFullscreen();
            } else if (ganttTableCard.webkitRequestFullscreen) {
                ganttTableCard.webkitRequestFullscreen();
            } else if (ganttTableCard.msRequestFullscreen) {
                ganttTableCard.msRequestFullscreen();
            }
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
    }

    // Toggle hide completed tasks
    function toggleHideCompleted() {
        hideCompleted = hideCompletedToggle.checked;
        saveFilterStates();
        renderTasks(filterTasks(allTasks));
        renderGanttCalendar(filterTasks(allTasks));
    }

    // Event listeners
    statusFilter.addEventListener('change', () => {
        saveFilterStates();
        renderTasks(filterTasks(allTasks));
        renderGanttCalendar(filterTasks(allTasks));
    });
    
    monthFilter.addEventListener('change', () => {
        saveFilterStates();
        renderTasks(filterTasks(allTasks));
        renderGanttCalendar(filterTasks(allTasks));
    });
    
    yearFilter.addEventListener('change', () => {
        saveFilterStates();
        renderTasks(filterTasks(allTasks));
        renderGanttCalendar(filterTasks(allTasks));
    });
    
    searchInput.addEventListener('input', () => {
        renderTasks(filterTasks(allTasks));
        renderGanttCalendar(filterTasks(allTasks));
    });

    hideCompletedToggle.addEventListener('change', toggleHideCompleted);

    toggleGanttBtn.addEventListener('click', toggleGanttVisibility);
    showGanttBtn.addEventListener('click', toggleGanttVisibility);
    currentMonthBtn.addEventListener('click', toggleCurrentMonthView);
    fullscreenBtn.addEventListener('click', toggleFullscreen);

    // Category transfer modal event listeners
    closeModalBtn.addEventListener('click', closeCategoryTransferModal);
    cancelTransferBtn.addEventListener('click', closeCategoryTransferModal);
    confirmTransferBtn.addEventListener('click', transferTaskToCategory);

    // Fullscreen event listeners
    document.addEventListener('fullscreenchange', () => {
        isFullscreen = !!document.fullscreenElement;
        fullscreenBtn.innerHTML = isFullscreen ? '<i class="fas fa-compress"></i>' : '<i class="fas fa-expand"></i>';
    });
    
    document.addEventListener('webkitfullscreenchange', () => {
        isFullscreen = !!document.webkitFullscreenElement;
        fullscreenBtn.innerHTML = isFullscreen ? '<i class="fas fa-compress"></i>' : '<i class="fas fa-expand"></i>';
    });
    
    document.addEventListener('msfullscreenchange', () => {
        isFullscreen = !!document.msFullscreenElement;
        fullscreenBtn.innerHTML = isFullscreen ? '<i class="fas fa-compress"></i>' : '<i class="fas fa-expand"></i>';
    });

    // Load filter states
    function loadFilterStates() {
        const savedStatus = localStorage.getItem('taskStatusFilter');
        const savedMonth = localStorage.getItem('taskMonthFilter');
        const savedYear = localStorage.getItem('taskYearFilter');
        const savedSearch = localStorage.getItem('taskSearchFilter');
        const savedGanttVisible = localStorage.getItem('ganttVisible');
        const savedShowCurrentMonthOnly = localStorage.getItem('showCurrentMonthOnly');
        const savedHideCompleted = localStorage.getItem('hideCompleted');
        
        if (savedStatus) statusFilter.value = savedStatus;
        if (savedMonth) monthFilter.value = savedMonth;
        if (savedYear) yearFilter.value = savedYear;
        if (savedSearch) searchInput.value = savedSearch;
        if (savedGanttVisible === 'true') {
            ganttVisible = true;
            toggleGanttBtn.innerHTML = '<i class="fas fa-eye-slash"></i>';
        } else {
            ganttVisible = false;
            toggleGanttBtn.innerHTML = '<i class="fas fa-eye"></i>';
        }
        if (savedShowCurrentMonthOnly === 'true') {
            showCurrentMonthOnly = true;
            currentMonthBtn.textContent = "All Months";
        }
        if (savedHideCompleted === 'true') {
            hideCompleted = true;
            hideCompletedToggle.checked = true;
        }
    }

    // Save filter states
    function saveFilterStates() {
        localStorage.setItem('taskStatusFilter', statusFilter.value);
        localStorage.setItem('taskMonthFilter', monthFilter.value);
        localStorage.setItem('taskYearFilter', yearFilter.value);
        localStorage.setItem('taskSearchFilter', searchInput.value);
        localStorage.setItem('hideCompleted', hideCompleted.toString());
    }

    // Load expanded tasks
    function loadExpandedTasks() {
        try {
            expandedTasks = JSON.parse(localStorage.getItem("expanded_tasks") || "{}");
        } catch (e) { expandedTasks = {}; }
    }

    // Save expanded tasks
    function saveExpandedTasks() {
        localStorage.setItem("expanded_tasks", JSON.stringify(expandedTasks));
    }

    // Theme toggle
    toggleModeBtn.addEventListener('click', function() {
        document.body.classList.toggle('light-mode');
        if (document.body.classList.contains('light-mode')) {
            this.innerHTML = '<i class="fas fa-moon"></i> Dark Mode';
            localStorage.setItem('theme', 'light');
        } else {
            this.innerHTML = '<i class="fas fa-sun"></i> Light Mode';
            localStorage.setItem('theme', 'dark');
        }
    });

    if (localStorage.getItem('theme') === 'light') {
        document.body.classList.add('light-mode');
        toggleModeBtn.innerHTML = '<i class="fas fa-moon"></i> Dark Mode';
    } else {
        toggleModeBtn.innerHTML = '<i class="fas fa-sun"></i> Light Mode';
    }

    // Initialize
    updateCategoryUI();
    loadFilterStates();
    loadExpandedTasks();
    
    // Set initial Gantt visibility
    if (ganttVisible) {
        ganttTableCard.classList.remove('hide');
        showGanttBtn.classList.add('hide');
        mainCard.style.flexBasis = '65%';
        ganttTableCard.style.flexBasis = '35%';
    } else {
        ganttTableCard.classList.add('hide');
        showGanttBtn.classList.remove('hide');
        mainCard.style.flexBasis = '100%';
    }
    
    // Load tasks
    loadAllTasks();

    // Refresh the calendar every minute to update the live ticking
    setInterval(() => {
        renderGanttCalendar(filterTasks(allTasks));
    }, 60000);

    // Make functions available globally
    window.deleteTask = deleteTask;
    window.showCategoryTransferModal = showCategoryTransferModal;
</script>
</body>
</html>
