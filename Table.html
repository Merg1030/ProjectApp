<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>IMS Weekly & Monthly Stock & Man Hour Report</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  body {
    font-family: Arial, sans-serif;
    background: #f7fafd;
    margin: 0;
  }

  .panel {
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(44,62,80,0.06);
    margin: 40px auto;
    padding: 30px;
    max-width: 1800px;
  }

  .panel-heading {
    background: #1976d2;
    color: #fff;
    padding: 18px 24px;
    font-size: 1.25rem;
    font-weight: bold;
    border-radius: 8px 8px 0 0;
    margin: -30px -30px 24px -30px;
    letter-spacing: 0.08em;
  }

  .filter-bar {
    margin-bottom: 20px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
  }

  label { font-weight: 600; margin-right: 7px; }

  input[type="number"], select {
    padding: 6px 14px;
    font-size: 1rem;
    border-radius: 4px;
    border: 1px solid #aaa;
  }

  button {
    padding: 7px 18px;
    background: #1976d2;
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
  }

  button:hover { background: #125195; }
  #download-pdf-btn { margin-left: 7px; background: #1976d2; }
  #download-pdf-btn:hover { background: #3770a9; }

  #report-output { margin-top: 0; margin-bottom: 30px; }

  /* ---------------- TABLE STYLES ---------------- */
  .report-table, .tracker-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 16px;
    font-size: 0.80rem;
    table-layout: auto;
    word-break: break-word;
  }

  .report-table th, .report-table td,
  .tracker-table th, .tracker-table td {
    text-align: left;
    padding: 6px 6px;
    border: 1px solid #ddd;
    vertical-align: top;
    overflow-wrap: break-word;
    word-break: break-word;
    white-space: normal;
    font-size: 11px;
  }

  .report-table th {
    color: #222;
    font-weight: bold;
    background: #f1f7fe;
  }

  .report-table tr:nth-child(even),
  .tracker-table tr:nth-child(even) {
    background: #f9fbfd;
  }

  .currency { font-weight: 500; color: #1976d2; }

  .total-row td {
    font-weight: bold;
    border-top: 2px solid #d1e4fc;
    color: #1976d2;
    background: #f1f7fe;
  }

  .total-cost-incurred {
    background: #eafbed;
    color: #0a7b1c;
    font-size: 1.10rem;
    font-weight: bold;
    padding: 10px 12px;
    border: 2px solid #b5e7c1;
    border-radius: 7px;
    margin-bottom: 16px;
    margin-top: 10px;
    text-align: right;
  }

  h3 { margin-top: 28px; }

  /* PDF-specific styles */
  @media print {
    body {
      background: #fff !important;
      margin: 0;
      padding: 0;
    }
    
    .panel {
      box-shadow: none;
      border-radius: 0;
      margin: 0;
      padding: 10px;
      width: 100%;
      max-width: 100%;
    }
    
    .panel-heading {
      margin: 0 0 15px 0;
      border-radius: 0;
    }
    
    .filter-bar {
      display: none !important;
    }
    
    table, tr, td, th, tbody, thead {
      page-break-inside: avoid !important;
    }
    
    h2, h3, h4 {
      page-break-after: avoid;
    }
    
    .report-table, .tracker-table {
      font-size: 9px;
    }
    
    .report-table th, .report-table td,
    .tracker-table th, .tracker-table td {
      padding: 4px 4px;
    }
    
    .pdf-section {
      margin-bottom: 15px;
    }
    
    .pdf-heading {
      margin-top: 10px;
      margin-bottom: 8px;
    }
  }

  /* ---------------- EMPLOYEE TRACKER ---------------- */
  .tracker-table th {
    color: #222;
    font-weight: bold;
    background: #f1f7fe;
    font-size: 0.75rem;
  }

  .comment-cell { width: 200px; }

  .comment-input {
    width: 100%;
    padding: 4px;
    border: 1px solid #ddd;
    border-radius: 3px;
    font-size: 0.75rem;
  }

  .project-breakdown {
    width: 250px;
    line-height: 1.3;
    font-size: 0.68rem;
    color: #137c05;
    font-weight: bolder;
  }

  .name-cell {
    width: 180px;
    font-weight: 600;
    font-size: 0.8rem;
  }

  .mh-cell, .unworked-cell, .workdays-cell, .absent-cell, .leave-cell, .sick-cell {
    width: 70px;
    text-align: center;
    font-size: 0.78rem;
  }

  /* ---------------- MATERIAL USAGE BREAKDOWN FIX ---------------- */
  .material-breakdown {
    display: inline-block;
    vertical-align: top;
    margin: 0;
    padding: 0;
    page-break-inside: avoid !important;
  }

  .material-breakdown table {
    width: 100%;
    margin: 0;
    border-collapse: collapse;
    page-break-inside: avoid !important;
  }

  .material-breakdown tr, 
  .material-breakdown td, 
  .material-breakdown th {
    page-break-inside: avoid !important;
  }

  /* ---------------- RESPONSIVE ---------------- */
  @media (max-width: 900px) {
    .panel { padding: 10px; margin: 10px; }

    .tracker-table { font-size: 0.7rem; }
    .tracker-table th, .tracker-table td { padding: 4px 2px; }

    .filter-bar { flex-direction: column; align-items: flex-start; }

    .project-breakdown { width: 180px; font-size: 0.6rem; }
    .name-cell { width: 140px; font-size: 0.7rem; }

    .mh-cell, .unworked-cell, .workdays-cell, .absent-cell, .leave-cell, .sick-cell {
      width: 50px;
      font-size: 0.7rem;
    }

    .comment-cell { width: 120px; }
    .comment-input { font-size: 0.65rem; }
  }
  
  /* PDF spacing fix */
  .pdf-section {
    margin-bottom: 20px;
    page-break-inside: avoid;
  }
  
  .pdf-heading {
    margin-top: 15px;
    margin-bottom: 10px;
    page-break-after: avoid;
  }
</style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
</head>
<body>
  <div class="panel">
    <div class="panel-heading">
      <a href="dashboard.html" class="btn btn-outline">
        ‚Üê Back
      </a>IMS Weekly, Monthly & Yearly Stock & Man Hour Report
    </div>
    <div class="filter-bar">
      <label for="report-type-select">Report Type:</label>
      <select id="report-type-select">
        <option value="week">Weekly</option>
        <option value="month">Monthly</option>
        <option value="year">Yearly</option>
      </select>
      <div id="week-controls">
        <label for="week-select">Week Number:</label>
        <input type="number" id="week-select" min="1" max="53" value="">
        <label for="week-year-select">Year:</label>
        <input type="number" id="week-year-select" min="2020" max="2100" step="1" style="width:90px;" />
      </div>
      <div id="month-controls" style="display:none;">
        <label for="month-select">Month:</label>
        <select id="month-select">
          <option value="0">January</option>
          <option value="1">February</option>
          <option value="2">March</option>
          <option value="3">April</option>
          <option value="4">May</option>
          <option value="5">June</option>
          <option value="6">July</option>
          <option value="7">August</option>
          <option value="8">September</option>
          <option value="9">October</option>
          <option value="10">November</option>
          <option value="11">December</option>
        </select>
        <label for="year-select">Year:</label>
        <input type="number" id="year-select" min="2020" max="2100" step="1" style="width:90px;" />
      </div>
      <div id="year-controls" style="display:none;">
        <label for="year-only-select">Year:</label>
        <input type="number" id="year-only-select" min="2020" max="2100" step="1" style="width:90px;" />
      </div>
      <div class="project-filter-block">
        <label for="project-select">Project:</label>
        <select id="project-select">
          <option value="">All Projects</option>
        </select>
      </div>
      <div class="toggle-tasks">
        <label><input type="checkbox" id="show-ongoing-checkbox" checked>Show Ongoing Tasks</label>
        <label><input type="checkbox" id="show-pending-checkbox" checked>Show Pending Tasks</label>
        <label><input type="checkbox" id="show-usage-checkbox" checked>Show Material Usage (Breakdown & General)</label>
      </div>
      <button id="generate-report-btn">Generate Report</button>
      <button id="download-pdf-btn" disabled>Download as PDF</button>
    </div>
    <div id="report-output"></div>
  </div>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
    import {
      getFirestore,
      collection,
      onSnapshot,
      query,
      orderBy,
      getDoc,
      doc,
      getDocs,
      where
    } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDXhhy94Aqmaav6X0UsfMcmsBT539-aheU",
      authDomain: "project-task-588c4.firebaseapp.com",
      projectId: "project-task-588c4",
      storageBucket: "project-task-588c4.appspot.com",
      messagingSenderId: "411882772509",
      appId: "1:411882772509:web:08d613186c101a99f38ef4",
      measurementId: "G-JMFLFYEM0F"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Cache objects to store fetched data
    let allUsages = [];
    let allTransfers = [];
    let materialCache = {};
    let projectCache = {};
    let taskHourCache = {};
    let taskMaterialCache = {};
    let projectOptions = {};

    // UI controls
    const reportTypeSelect = document.getElementById("report-type-select");
    const weekControls = document.getElementById("week-controls");
    const monthControls = document.getElementById("month-controls");
    const yearControls = document.getElementById("year-controls");
    const showOngoingCheckbox = document.getElementById("show-ongoing-checkbox");
    const showPendingCheckbox = document.getElementById("show-pending-checkbox");
    const usageCheckbox = document.getElementById('show-usage-checkbox');

    const projectSelect = document.getElementById("project-select");
    const reportOutput = document.getElementById("report-output");
    let lastReportHTML = '';
    let lastReportType = '';
    let lastReportPeriod = '';

    // ===== COMMENT PERSISTENCE =====
    // Load all comments from localStorage
    function loadAllComments() {
      try {
        return JSON.parse(localStorage.getItem("ims_comments")) || {};
      } catch {
        return {};
      }
    }
    // Save all comments to localStorage
    function saveAllComments(commentsData) {
      try {
        localStorage.setItem("ims_comments", JSON.stringify(commentsData));
      } catch {}
    }
    let commentsData = loadAllComments();

    // Period switch
    reportTypeSelect.onchange = function() {
      if (reportTypeSelect.value === "week") {
        weekControls.style.display = "";
        monthControls.style.display = "none";
        yearControls.style.display = "none";
      } else if (reportTypeSelect.value === "month") {
        weekControls.style.display = "none";
        monthControls.style.display = "";
        yearControls.style.display = "none";
      } else {
        weekControls.style.display = "none";
        monthControls.style.display = "none";
        yearControls.style.display = "";
      }
    };

    // Function to calculate workdays in a month (excluding Sundays, counting Saturdays as half days)
    function getWorkdaysInMonth(month, year) {
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      let workdays = 0;
      
      for (let day = 1; day <= daysInMonth; day++) {
        const date = new Date(year, month, day);
        const dayOfWeek = date.getDay();
        
        if (dayOfWeek !== 0) { // Not Sunday
          if (dayOfWeek === 6) { // Saturday (half day)
            workdays += 0.5;
          } else {
            workdays += 1;
          }
        }
      }
      
      return workdays;
    }

    // Function to calculate expected hours for a month
    function getExpectedMonthlyHours(month, year) {
      const workdays = getWorkdaysInMonth(month, year);
      return workdays * 8; // 8 hours per workday
    }

    function getWeekNumber(d) {
      d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
      d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay()||7));
      var yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
      var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1)/7);
      return weekNo;
    }

    function getWeekNumberFromDate(date) {
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay()||7));
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
      const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1)/7);
      return { week: weekNo, year: d.getUTCFullYear() };
    }

    function isSameMonthYear(date, month, year) {
      return date.getMonth() === month && date.getFullYear() === year;
    }

    function isSameYear(date, year) {
      return date.getFullYear() === year;
    }

    function safeProjectName(row) {
      return typeof row.projectName === "string"
        ? row.projectName
        : (row.projectName && row.projectName.name)
          ? row.projectName.name
          : (row.projectName && row.projectName.toString && row.projectName.toString() !== '[object Object]'
              ? row.projectName.toString()
              : '-');
    }

    async function getProjectNameCached(projectId) {
      if (!projectId) return "-";
      if (projectCache[projectId]) {
        return typeof projectCache[projectId] === 'string'
          ? projectCache[projectId]
          : (projectCache[projectId].name || '-');
      }
      try {
        const projSnap = await getDoc(doc(db, "projectDashboard", projectId));
        if (projSnap.exists()) {
          const name = projSnap.data().name || "-";
          projectCache[projectId] = name;
          projectOptions[projectId] = name;
          updateProjectDropdownOptions();
          return name;
        }
      } catch {}
      projectCache[projectId] = "-";
      return "-";
    }

    async function getHoursForTask(taskId) {
      if (!taskId) return 0;
      if (taskHourCache[taskId] !== undefined) {
        return taskHourCache[taskId];
      }
      try {
        const q = query(collection(db, "locationHistory"), where("taskId", "==", taskId));
        const snap = await getDocs(q);
        let sum = 0;
        snap.forEach(doc => {
          const d = doc.data();
          if (d.mh && !isNaN(d.mh)) sum += Number(d.mh);
        });
        taskHourCache[taskId] = sum;
        return sum;
      } catch (e) {
        console.error("Error getting hours for task", taskId, e);
        return 0;
      }
    }

    async function getMaterialCostForTask(taskId) {
      if (!taskId) return 0;
      if (taskMaterialCache[taskId] !== undefined) {
        return taskMaterialCache[taskId];
      }
      try {
        const q = query(collection(db, "materialsUsage"), where("taskId", "==", taskId));
        const snap = await getDocs(q);
        let sum = 0;
        const materialIds = new Set();
        snap.forEach(doc => {
          const d = doc.data();
          if (d.materialId) materialIds.add(d.materialId);
        });
        const materialPriceMap = {};
        await Promise.all([...materialIds].map(async materialId => {
          if (!materialCache[materialId]) {
            const matSnap = await getDoc(doc(db, "materials", materialId));
            if (matSnap.exists()) {
              materialCache[materialId] = matSnap.data().unitPrice || 0;
            }
          }
          materialPriceMap[materialId] = materialCache[materialId] || 0;
        }));
        snap.forEach(doc => {
          const d = doc.data();
          if (!d.reversed) {
            if (d.quantity && d.materialId) {
              const price = materialPriceMap[d.materialId] || 0;
              sum += Number(d.quantity) * Number(price);
            }
            else if (d.boughtFromSupplier && d.amount) {
              sum += Number(d.amount);
            }
            else if (d.quantity && d.unitPrice && !d.materialId) {
              sum += Number(d.quantity) * Number(d.unitPrice);
            }
          }
        });
        taskMaterialCache[taskId] = sum;
        return sum;
      } catch (e) {
        console.error("Error getting material cost for task", taskId, e);
        return 0;
      }
    }

    function updateProjectDropdownOptions() {
      const select = document.getElementById("project-select");
      if (!select) return;
      const current = select.value;
      select.innerHTML = '<option value="">All Projects</option>';
      Object.entries(projectOptions)
        .sort((a, b) => String(a[1]).localeCompare(String(b[1])))
        .forEach(([id, name]) => {
          const opt = document.createElement("option");
          opt.value = id;
          opt.textContent = name;
          select.appendChild(opt);
        });
      if (current && select.querySelector(`[value="${current}"]`)) select.value = current;
    }

    async function fetchAllTasksFlat() {
      const mainTaskSnaps = await getDocs(collection(db, "projectTasks"));
      let all = [];
      await Promise.all(mainTaskSnaps.docs.map(async (mainDoc) => {
        const main = { ...mainDoc.data(), _id: mainDoc.id, _type: "main" };
        main.projectName = await getProjectNameCached(main.projectId);
        if (main.projectId && main.projectName) projectOptions[main.projectId] = main.projectName;
        const [hours, materialCost] = await Promise.all([
          getHoursForTask(main.taskId),
          getMaterialCostForTask(main.taskId)
        ]);
        main._durationHours = hours;
        main._materialCost = materialCost;
        all.push(main);
        const subSnap = await getDocs(collection(db, "projectTasks", mainDoc.id, "subtasks"));
        await Promise.all(subSnap.docs.map(async (subDoc) => {
          const sub = { ...subDoc.data(), _id: subDoc.id, _type: "sub", parentTaskId: main.taskId, projectName: main.projectName, projectId: main.projectId };
          const [subHours, subMaterialCost] = await Promise.all([
            getHoursForTask(sub.taskId),
            getMaterialCostForTask(sub.taskId)
          ]);
          sub._durationHours = subHours;
          sub._materialCost = subMaterialCost;
          all.push(sub);
          const subSubSnap = await getDocs(collection(db, "projectTasks", mainDoc.id, "subtasks", subDoc.id, "subsubtasks"));
          await Promise.all(subSubSnap.docs.map(async (subSubDoc) => {
            const subsub = { ...subSubDoc.data(), _id: subSubDoc.id, _type: "subsub", parentTaskId: sub.taskId, projectName: main.projectName, projectId: main.projectId };
            const [subsubHours, subsubMaterialCost] = await Promise.all([
              getHoursForTask(subsub.taskId),
              getMaterialCostForTask(subsub.taskId)
            ]);
            subsub._durationHours = subsubHours;
            subsub._materialCost = subsubMaterialCost;
            all.push(subsub);
          }));
        }));
      }));
      updateProjectDropdownOptions();
      return all;
    }

    // Fetch all employees from Firestore
async function fetchEmployees() {
  const empSnap = await getDocs(collection(db, "employees"));
  const empMap = {};
  
  empSnap.forEach(doc => {
    const data = doc.data();
    // Correct fullName concatenation
    const fullName = ((data.name || "") + " " + (data.surname || "")).trim().toUpperCase();
    empMap[fullName] = { id: doc.id, ...data };
  });

  return empMap;
}


    // Fetch location history for MH calculation
    async function fetchLocationHistory(periodType, periodObj, projectFilter) {
      const locSnap = await getDocs(query(collection(db, "locationHistory"), orderBy("transferredAt", "desc")));
      const locMap = {};
      locSnap.forEach(doc => {
        const data = doc.data();
        if (!data.employeeId || !data.transferredAt || data.reversed) return;
        const d = data.transferredAt.toDate ? data.transferredAt.toDate() : new Date(data.transferredAt);
        let inPeriod = false;
        
        if (periodType === "month") {
          if (isSameMonthYear(d, periodObj.month, periodObj.year)) inPeriod = true;
        } else if (periodType === "week") {
          const { week, year } = getWeekNumberFromDate(d);
          if (week === periodObj.week && year === periodObj.year) inPeriod = true;
        } else if (periodType === "year") {
          if (isSameYear(d, periodObj.year)) inPeriod = true;
        }
        
        if (inPeriod) {
          // Apply project filter
          if (projectFilter && data.projectId !== projectFilter) return;
          
          if (!locMap[data.employeeId]) locMap[data.employeeId] = [];
          locMap[data.employeeId].push({...data, _date: d, id: doc.id});
        }
      });
      return locMap;
    }

    // Helper: Get project hours breakdown string for employee for the selected period
    function getProjectHoursBreakdown(employeeLocRecords) {
      const projectHours = {};

      employeeLocRecords.forEach(record => {
        let projectName =
          record.projectName ||
          record.project ||
          (
            record.taskDescription
            ? record.taskDescription.split(' - ')[0]
            : ""
          );

        if (!projectName) projectName = "UNKNOWN PROJECT";

        const hours = Number(record.mh) || 0;
        if (!projectHours[projectName]) projectHours[projectName] = 0;
        projectHours[projectName] += hours;
      });

      // Format breakdown string: "Painting (32) Doors installation (16)"
      let breakdown = "";
      for (const [project, hours] of Object.entries(projectHours)) {
        if (hours > 0) {
          breakdown += `${project} (${hours}) `;
        }
      }
      return breakdown.trim() || "No project data";
    }

    // Generate employee tracker table
    async function generateEmployeeTracker(periodType, periodObj, projectFilter, projectFilterName) {
      try {
        // Fetch employees and location history
        const [empMap, locMap] = await Promise.all([
          fetchEmployees(),
          fetchLocationHistory(periodType, periodObj, projectFilter)
        ]);

        // Remove Techno Department and Christopher Chishela
        const allEmployeeNames = Object.keys(empMap)
          .filter(name =>
            !name.includes("TECHNO DEPARTMENT") &&
            !name.includes("CHRISTOPHER CHISHELA")
          )
          .sort();

        let html = `
  <div class="pdf-section">
    <h3 class="pdf-heading" style="color:#1976d2; margin: 30px 0 15px 0;">
      ${periodType === 'week' ? 'Week' : periodType === 'month' ? 'Month' : 'Year'} 
      ${periodObj.week || periodObj.month + 1 || periodObj.year} 
      (${periodObj.year}) Employee Days / MH Tracker 
      ${projectFilterName ? " - " + projectFilterName : ""}
    </h3>
    <table class="tracker-table">
      <thead>
        <tr>
          <th class="name-cell">NAME</th>
          <th class="project-breakdown">PROJECT NAME & HOURS BREAKDOWN</th>
          <th class="mh-cell">MH</th>
          <th class="unworked-cell">UNWORKED</th>
          <th class="workdays-cell">W/D</th>
          <th class="absent-cell">A/DAYS</th>
          <th class="leave-cell">L/DAYS</th>
          <th class="sick-cell">S/DAY</th>
          <th class="comment-cell">COMMENT</th>
        </tr>
      </thead>
      <tbody>
`;

        let totalMH = 0;
        let totalUnworked = 0;
        let totalWorkDays = 0;
        let totalAbsentDays = 0;
        let totalLeaveDays = 0;
        let totalSickDays = 0;

        for (const name of allEmployeeNames) {
          const emp = empMap[name] || null;
          let employeeId = emp ? emp.id : null;

          // LocationHistory records for this employee in the selected period
          const employeeLocRecords = (employeeId && locMap[employeeId]) ? locMap[employeeId] : [];

          // MH
          let mhWorked = employeeLocRecords.reduce((sum, record) => sum + (Number(record.mh) || 0), 0);

          // Project Hours Breakdown
          const projectHoursBreakdown = getProjectHoursBreakdown(employeeLocRecords);

          // W/D calculation: count unique dates EXCEPT those where taskDescription includes absent, sick, or leave
          const workedDaysSet = new Set();
          // For each type, count unique dates with those taskDescriptions
          const absentDaysSet = new Set();
          const leaveDaysSet = new Set();
          const sickDaysSet = new Set();

          employeeLocRecords.forEach(record => {
            const desc = (record.taskDescription || "").toLowerCase();
            const d = record._date;
            const dayStr = d.toISOString().slice(0, 10);

            if (desc.indexOf("absent") !== -1) {
              absentDaysSet.add(dayStr);
            }
            if (desc.indexOf("leave") !== -1) {
              leaveDaysSet.add(dayStr);
            }
            if (desc.indexOf("sick") !== -1) {
              sickDaysSet.add(dayStr);
            }
            // Worked day = not absent/leave/sick
            if (
              desc.indexOf("absent") === -1 &&
              desc.indexOf("leave") === -1 &&
              desc.indexOf("sick") === -1
            ) {
              workedDaysSet.add(dayStr);
            }
          });

          let workDays = workedDaysSet.size;
          let absentDays = absentDaysSet.size;
          let leaveDays = leaveDaysSet.size;
          let sickDays = sickDaysSet.size;

          // Unworked hours calculation
          let unworkedHours = 0;
          if (periodType === "week") {
            unworkedHours = 45 - mhWorked;
          } else if (periodType === "month") {
            // Calculate expected hours for the month
            const expectedHours = getExpectedMonthlyHours(periodObj.month, periodObj.year);
            unworkedHours = expectedHours - mhWorked;
          } else if (periodType === "year") {
            // For yearly reports, don't calculate unworked hours
            unworkedHours = 0;
          }

          totalMH += mhWorked;
          totalUnworked += unworkedHours > 0 ? unworkedHours : 0;
          totalWorkDays += workDays;
          totalAbsentDays += absentDays;
          totalLeaveDays += leaveDays;
          totalSickDays += sickDays;

          // COMMENT LOGIC - unique per employee per period
          const commentId = `${name}-${periodType}-${periodObj.week || periodObj.month || 'year'}-${periodObj.year}`;
          // Load from persisted commentsData
          const savedComment = commentsData[commentId] || "";

          html += `<tr>
            <td class="name-cell">${name}</td>
            <td class="project-breakdown">${projectHoursBreakdown}</td>
            <td class="mh-cell">${mhWorked.toFixed(1)}</td>
            <td class="unworked-cell">${unworkedHours > 0 ? unworkedHours.toFixed(1) : '0'}</td>
            <td class="workdays-cell">${workDays}</td>
            <td class="absent-cell">${absentDays}</td>
            <td class="leave-cell">${leaveDays}</td>
            <td class="sick-cell">${sickDays}</td>
            <td class="comment-cell">
              <input type="text" class="comment-input" data-id="${commentId}" 
                     value="${savedComment}" placeholder="Add comment">
            </td>
          </tr>`;
        }

        html += `<tr class="total-row">
          <td>TOTAL</td>
          <td></td>
          <td>${totalMH.toFixed(1)}</td>
          <td>${totalUnworked.toFixed(1)}</td>
          <td>${totalWorkDays}</td>
          <td>${totalAbsentDays}</td>
          <td>${totalLeaveDays}</td>
          <td>${totalSickDays}</td>
          <td></td>
        </tr>`;

        html += `</tbody></table></div>`;

        // ===== Save comments instantly and persistently =====
        setTimeout(() => {
          document.querySelectorAll('.comment-input').forEach(input => {
            input.addEventListener('change', function() {
              commentsData[this.dataset.id] = this.value;
              saveAllComments(commentsData);
            });
          });
        }, 100);

        return html;
      } catch (err) {
        console.error("Error generating employee tracker:", err);
        return `<p style="color:red;">Error generating employee tracker: ${err.message}</p>`;
      }
    }

    onSnapshot(collection(db, "projectDashboard"), snapshot => {
      snapshot.docs.forEach(docSnap => {
        const d = docSnap.data();
        if (docSnap.id && d.name) {
          projectOptions[docSnap.id] = d.name;
        }
      });
      updateProjectDropdownOptions();
    });

    onSnapshot(query(collection(db, "materialsUsage"), orderBy("assignedAt", "desc")), async (snapshot) => {
      allUsages = [];
      materialCache = {};
      projectCache = {};
      const usageDocs = snapshot.docs;
      await Promise.all(usageDocs.map(async (docSnap) => {
        const u = docSnap.data();
        if (u.projectId && !projectCache[u.projectId]) {
          try {
            const projSnap = await getDoc(doc(db, "projectDashboard", u.projectId));
            if (projSnap.exists()) {
              const name = projSnap.data().name || "-";
              projectCache[u.projectId] = name;
              projectOptions[u.projectId] = name;
            } else {
              projectCache[u.projectId] = "-";
            }
          } catch { projectCache[u.projectId] = "-"; }
        }
        if (u.materialId && !materialCache[u.materialId]) {
          try {
            const matSnap = await getDoc(doc(db, "materials", u.materialId));
            if (matSnap.exists()) materialCache[u.materialId] = matSnap.data().unitPrice !== undefined ? matSnap.data().unitPrice : "-";
            else materialCache[u.materialId] = "-";
          } catch { materialCache[u.materialId] = "-"; }
        }
        let usage = { ...u };
        if (u.projectId && projectCache[u.projectId]) usage.projectName = projectCache[u.projectId];
        else if (u.projectName) usage.projectName = u.projectName;
        else usage.projectName = "-";
        if (u.materialId) usage.unitPrice = materialCache[u.materialId] !== undefined ? materialCache[u.materialId] : "-";
        if (u.assignedAt && u.assignedAt.toDate) {
          usage._date = u.assignedAt.toDate();
          usage._week = getWeekNumber(usage._date);
        }
        allUsages.push(usage);
      }));
      updateProjectDropdownOptions();
      updateDefaultWeekAndMonth();
    });

    onSnapshot(query(collection(db, "locationHistory"), orderBy("transferredAt", "desc")), async (snapshot) => {
      allTransfers = [];
      const projIds = new Set();
      snapshot.docs.forEach(docSnap => {
        const d = docSnap.data();
        if (!d.reversed) {
          if (d.transferredAt && d.transferredAt.toDate) {
            d._date = d.transferredAt.toDate();
            d._week = getWeekNumber(d._date);
          }
          d.id = docSnap.id;
          allTransfers.push(d);
          if (d.projectId) projIds.add(d.projectId);
        }
      });
      await Promise.all([...projIds].map(async id => {
        if (!projectCache[id]) {
          try {
            const snap = await getDoc(doc(db, "projectDashboard", id));
            if (snap.exists()) {
              const name = snap.data().name || "-";
              projectCache[id] = name;
              projectOptions[id] = name;
            }
          } catch {}
        }
      }));
      updateProjectDropdownOptions();
      updateDefaultWeekAndMonth();
    });

    function updateDefaultWeekAndMonth() {
      let latestStockWeek = 0, latestMHWeek = 0, latestStockDate = null;
      allUsages.forEach(u => {
        if (u._week && u._week > latestStockWeek) latestStockWeek = u._week;
        if (u._date && (!latestStockDate || u._date > latestStockDate)) latestStockDate = u._date;
      });
      allTransfers.forEach(d => {
        if (d._week && d._week > latestMHWeek) latestMHWeek = d._week;
        if (d._date && (!latestStockDate || d._date > latestStockDate)) latestStockDate = u._date;
      });
      let wk = Math.max(latestStockWeek, latestMHWeek) || 1;
      const now = new Date();
      document.getElementById("week-select").value = wk;
      document.getElementById("week-year-select").value = latestStockDate ? latestStockDate.getFullYear() : now.getFullYear();
      if (latestStockDate) {
        document.getElementById("month-select").value = latestStockDate.getMonth();
        document.getElementById("year-select").value = latestStockDate.getFullYear();
        document.getElementById("year-only-select").value = latestStockDate.getFullYear();
      } else {
        document.getElementById("month-select").value = now.getMonth();
        document.getElementById("year-select").value = now.getFullYear();
        document.getElementById("year-only-select").value = now.getFullYear();
      }
    }

    async function getAccountTotalsForCashReport(month, year, forMonth, week, forWeek, weekYear, forYear, yearOnly, projectIdFilter) {
      const expensesCol = collection(db, "General expenses");
      const snap = await getDocs(expensesCol);
      let expenses = snap.docs.map(doc => doc.data());
      if (projectIdFilter) {
        expenses = expenses.filter(exp => exp.projectId === projectIdFilter);
      }
      if (forMonth) {
        expenses = expenses.filter(exp => {
          if (!exp.date) return false;
          const d = new Date(exp.date);
          return d.getMonth() === month && d.getFullYear() === year;
        });
      } else if (forWeek && week && weekYear) {
        expenses = expenses.filter(exp => {
          if (!exp.date) return false;
          const d = new Date(exp.date);
          const { week: expWeek, year: expYear } = getWeekNumberFromDate(d);
          return expWeek === week && expYear === weekYear;
        });
      } else if (forYear && yearOnly) {
        expenses = expenses.filter(exp => {
          if (!exp.date) return false;
          const d = new Date(exp.date);
          return d.getFullYear() === yearOnly;
        });
      }
      const accounts = [
        "Hazida Limited",
        "Freight n Passengers",
        "Hazida Motors",
        "Hazida Ezone Limited"
      ];
      let accountTotals = {};
      let grandTotal = 0;
      accounts.forEach(acc => accountTotals[acc] = 0);
      expenses.forEach(exp => {
        const acc = accounts.find(a =>
          (exp.account || "").trim().toLowerCase() === a.toLowerCase()
        );
        if (acc && typeof exp.amount === "number") {
          accountTotals[acc] += exp.amount;
          grandTotal += exp.amount;
        }
      });
      return { accountTotals, grandTotal, accounts };
    }

    document.getElementById("generate-report-btn").onclick = async function() {
      const generateBtn = document.getElementById("generate-report-btn");
      const originalBtnText = generateBtn.textContent;
      generateBtn.disabled = true;
      generateBtn.textContent = "Generating...";
      document.getElementById("report-output").innerHTML = '<div class="loading-spinner"></div><p style="text-align:center;">Generating report, please wait...</p>';
      
      try {
        taskHourCache = {};
        taskMaterialCache = {};
        const allTasksFlat = await fetchAllTasksFlat();

        const showOngoing = showOngoingCheckbox.checked;
        const showPending = showPendingCheckbox.checked;
        const projectFilter = projectSelect.value || "";
        const projectFilterName = projectOptions[projectFilter] || "";
        const isSpecificProject = !!projectFilter;

        let stockTotals = {}, totalStockSpent = 0;
        const COST_PER_HOUR = 20;
        let manHourTotals = {}, totalMH = 0, totalMHCost = 0;
        let periodLabel = "";
        let filterUsages, filterTransfers;

        let forMonth = reportTypeSelect.value === "month";
        let forWeek = reportTypeSelect.value === "week";
        let forYear = reportTypeSelect.value === "year";
        let month = forMonth ? parseInt(document.getElementById("month-select").value) : null;
        let year = forMonth ? parseInt(document.getElementById("year-select").value) : null;
        let week = forWeek ? parseInt(document.getElementById("week-select").value) : null;
        let weekYear = forWeek ? parseInt(document.getElementById("week-year-select").value) : null;
        let yearOnly = forYear ? parseInt(document.getElementById("year-only-select").value) : null;

        if (forMonth) {
          const monthVal = parseInt(document.getElementById("month-select").value);
          const yearVal = parseInt(document.getElementById("year-select").value);
          periodLabel = `Month: ${document.getElementById("month-select").options[monthVal].text} ${yearVal}${projectFilterName ? " | Project: " + projectFilterName : ""}`;
          filterUsages = allUsages.filter(u => u._date && isSameMonthYear(u._date, monthVal, yearVal));
          filterTransfers = allTransfers.filter(d => d._date && isSameMonthYear(d._date, monthVal, yearVal));
        } else if (forWeek) {
          const weekToReport = week;
          periodLabel = `Week ${weekToReport} (${weekYear})${projectFilterName ? " | Project: " + projectFilterName : ""}`;
          filterUsages = allUsages.filter(u => {
            if (!u._date) return false;
            const { week: w, year: y } = getWeekNumberFromDate(u._date);
            return w === weekToReport && y === weekYear;
          });
          filterTransfers = allTransfers.filter(d => {
            if (!d._date) return false;
            const { week: w, year: y } = getWeekNumberFromDate(d._date);
            return w === weekToReport && y === weekYear;
          });
        } else if (forYear) {
          const yearToReport = yearOnly;
          periodLabel = `Year: ${yearToReport}${projectFilterName ? " | Project: " + projectFilterName : ""}`;
          filterUsages = allUsages.filter(u => {
            if (!u._date) return false;
            return isSameYear(u._date, yearToReport);
          });
          filterTransfers = allTransfers.filter(d => {
            if (!d._date) return false;
            return isSameYear(d._date, yearToReport);
          });
        }

        // Apply project filter
        if (projectFilter) {
          filterUsages = filterUsages.filter(u => u.projectId === projectFilter);
          filterTransfers = filterTransfers.filter(d => d.projectId === projectFilter);
        }

        let mainHtml = `<div id="report-export-section">`;

        // Cash Report Section
        const {accountTotals, grandTotal, accounts} = await getAccountTotalsForCashReport(
          month, year, forMonth, week, forWeek, weekYear, forYear, yearOnly, projectFilter
        );

        mainHtml += `
        <div class="pdf-section" id="cash-report-section">
          <h2 style="color:#1976d2;">Cash Received Report</h2>
          <table class="report-table">
            <thead>
              <tr>
                <th>Account name</th>
                <th>Total cost incurred</th>
              </tr>
            </thead>
            <tbody>`;
        accounts.forEach(acc => {
          mainHtml += `
            <tr>
              <td>${acc}</td>
              <td>${accountTotals[acc].toLocaleString(undefined,{maximumFractionDigits:2})}</td>
            </tr>`;
        });
        mainHtml += `
            <tr class="total-row">
              <td>Total</td>
              <td>${grandTotal.toLocaleString(undefined,{maximumFractionDigits:2})}</td>
            </tr>
          </tbody>
          </table>
        </div>`;

        // --- INVENTORY FLOW BREAKDOWN ---
        let breakdownRows = [];
        let generalUseTotals = {};
        let closingBalance = 0;

        if (usageCheckbox.checked) {
          filterUsages.slice().sort((a, b) => {
            let dA = a.assignedAt && a.assignedAt.toDate ? a.assignedAt.toDate() : (a._date || new Date());
            let dB = b.assignedAt && b.assignedAt.toDate ? b.assignedAt.toDate() : (b._date || new Date());
            return dA - dB;
          }).forEach(u => {
            const dateStr = u.assignedAt && u.assignedAt.toDate ? u.assignedAt.toDate().toLocaleDateString() : "-";
            const taskId = u.taskId || "-";
            const name = u.materialName || "-";
            const qty = Number(u.quantity || 0);
            const unitPrice = Number(u.unitPrice || 0);
            const total = qty * unitPrice;
            breakdownRows.push({ dateStr, taskId, name, qty, unitPrice, total });
            generalUseTotals[name] = (generalUseTotals[name] || 0) + qty;
            closingBalance += total;
          });
        }

        const generalUseArr = Object.entries(generalUseTotals).map(([name, totalUsed]) => ({ name, totalUsed }));

        mainHtml += `
          <div class="pdf-section">
            <h2 style="color:#1976d2;">${periodLabel} Inventory Flow Breakdown ${projectFilterName ? " - " + projectFilterName : ""}</h2>
            <div class="total-cost-incurred">Total Cost Incurred: ZMW ${closingBalance.toLocaleString(undefined, {maximumFractionDigits:2})}</div>
            <h3 class="pdf-heading">Break down use</h3>
            <table class="report-table">
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Task ID</th>
                  <th>Name</th>
                  <th>Qty</th>
                  <th>Unit Price</th>
                  <th>Total</th>
                </tr>
              </thead>
              <tbody>
                ${breakdownRows.map(r => `
                  <tr>
                    <td>${r.dateStr}</td>
                    <td>${r.taskId}</td>
                    <td>${r.name}</td>
                    <td>${r.qty}</td>
                    <td>${r.unitPrice}</td>
                    <td>${r.total}</td>
                  </tr>
                `).join('')}
                <tr class="total-row">
                  <td colspan="5" style="text-align:right;">Closing Balance</td>
                  <td>${closingBalance.toLocaleString(undefined, {maximumFractionDigits:2})}</td>
                </tr>
              </tbody>
            </table>
            <h4 class="pdf-heading">General use summary</h4>
            <table class="report-table">
              <thead>
                <tr>
                  <th>Material Name</th>
                  <th>Total Used</th>
                </tr>
              </thead>
              <tbody>
                ${generalUseArr.map(g => `
                  <tr>
                    <td>${g.name}</td>
                    <td>${g.totalUsed}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        `;

        // Inventory Flow Report
        mainHtml += `
        <div class="pdf-section">
          <h3 class="pdf-heading">Inventory Flow Report</h3>
          <table class="report-table">
            <thead>
              <tr>
                <th>Project Name</th>
                <th>Cost Incurred</th>
              </tr>
            </thead>
            <tbody>`;
        
        filterUsages.forEach(u => {
          if (u.reversed) return;
          let projectName = "-";
          if (typeof u.projectName === "string") projectName = u.projectName;
          else if (u.projectId && projectCache[u.projectId]) {
            projectName = (typeof projectCache[u.projectId] === "string")
              ? projectCache[u.projectId]
              : (projectCache[u.projectId].name || "-");
          }
          const qty = parseFloat(u.quantity || 0);
          const unitPrice = parseFloat(u.unitPrice || 0);
          const assignedValue = qty * unitPrice;
          if (!stockTotals[projectName]) stockTotals[projectName] = 0;
          stockTotals[projectName] += assignedValue;
          totalStockSpent += assignedValue;
        });

        Object.entries(stockTotals).forEach(([projectName, value]) => {
          mainHtml += `<tr>
            <td>${projectName}</td>
            <td>${Number(value).toLocaleString(undefined, {maximumFractionDigits:2})}</td>
          </tr>`;
        });
       mainHtml += `
  <tr class="total-row">
    <td>Total Spent</td>
    <td>${Number(totalStockSpent).toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
  </tr>
  </tbody>
  </table>
</div>
`;

// Man Hour Summary
mainHtml += `
  <div class="pdf-section">
    <h3 class="pdf-heading">Man Hour Summary</h3>
    <table class="report-table">
      <thead>
        <tr>
          <th>Project</th>
          <th>MAN HOUR</th>
          <th>COST</th>
        </tr>
      </thead>
      <tbody>
`;
        
filterTransfers.forEach(d => {
  let projectName = "-";
  if (d.projectId && projectCache[d.projectId]) {
    projectName = typeof projectCache[d.projectId] === "string"
      ? projectCache[d.projectId]
      : (projectCache[d.projectId].name || "-");
  }
  const mh = parseFloat(d.mh || 0);
  if (!manHourTotals[projectName]) manHourTotals[projectName] = 0;
  manHourTotals[projectName] += mh;
  totalMH += mh;
  totalMHCost += mh * COST_PER_HOUR;
});

Object.entries(manHourTotals).forEach(([project, mh]) => {
  mainHtml += `
    <tr>
      <td>${project}</td>
      <td>${mh}</td>
      <td>${(mh * COST_PER_HOUR).toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
    </tr>`;
});

mainHtml += `
    </tbody>
    <tfoot>
      <tr class="total-row">
        <td>Total Spent</td>
        <td>${totalMH}</td>
        <td>${totalMHCost.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
      </tr>
    </tfoot>
  </table>
</div>
`;

 // Add Employee Tracker Table
        const periodObj = forMonth ? {month, year} : forWeek ? {week, year: weekYear} : {year: yearOnly};
        const employeeTrackerHtml = await generateEmployeeTracker(
          reportTypeSelect.value, 
          periodObj, 
          projectFilter, 
          projectFilterName
        );
        
        mainHtml += employeeTrackerHtml;

        // Tasks Section
        let completedTasks = [], ongoingTasks = [], pendingTasks = [];
        let filteredTasksFlat = allTasksFlat;
        if (projectFilter) {
          filteredTasksFlat = allTasksFlat.filter(t => t.projectId === projectFilter);
        }

        if (forMonth) {
          completedTasks = filteredTasksFlat.filter(t => {
            if (!t.status || (t.status || '').toLowerCase() !== 'completed') return false;
            let inMonth = false;
            if (t.startDate) {
              const sd = t.startDate.toDate ? t.startDate.toDate() : new Date(t.startDate);
              if (sd.getMonth() === month && sd.getFullYear() === year) inMonth = true;
            }
            if (t.endDate) {
              const ed = t.endDate.toDate ? t.endDate.toDate() : new Date(t.endDate);
              if (ed.getMonth() === month && ed.getFullYear() === year) inMonth = true;
            }
            return inMonth;
          });
        } else if (forWeek) {
          completedTasks = filteredTasksFlat.filter(t => {
            if (!t.status || (t.status || '').toLowerCase() !== 'completed') return false;
            let inWeek = false;
            if (t.startDate) {
              const sd = t.startDate.toDate ? t.startDate.toDate() : new Date(t.startDate);
              const { week: w, year: y } = getWeekNumberFromDate(sd);
              if (w === week && y === weekYear) inWeek = true;
            }
            if (t.endDate) {
              const ed = t.endDate.toDate ? t.endDate.toDate() : new Date(t.endDate);
              const { week: w, year: y } = getWeekNumberFromDate(ed);
              if (w === week && y === weekYear) inWeek = true;
            }
            return inWeek;
          });
        } else if (forYear) {
          completedTasks = filteredTasksFlat.filter(t => {
            if (!t.status || (t.status || '').toLowerCase() !== 'completed') return false;
            let inYear = false;
            if (t.startDate) {
              const sd = t.startDate.toDate ? t.startDate.toDate() : new Date(t.startDate);
              if (sd.getFullYear() === yearOnly) inYear = true;
            }
            if (t.endDate) {
              const ed = t.endDate.toDate ? t.endDate.toDate() : new Date(t.endDate);
              if (ed.getFullYear() === yearOnly) inYear = true;
            }
            return inYear;
          });
        }

        ongoingTasks = showOngoing ? filteredTasksFlat.filter(t => (t.status || '').toLowerCase() === 'ongoing') : [];
        pendingTasks = showPending ? filteredTasksFlat.filter(t => (t.status || '').toLowerCase() === 'pending') : [];

        // COMPLETED TASKS TABLE
        if (completedTasks.length > 0) {
          mainHtml += `
          <div class="pdf-section">
            <h3 class="pdf-heading">COMPLETED TASKS</h3>
            <table class="report-table">
              <thead>
                <tr>
                  <th>PROJECT</th>
                  <th>TASK ID</th>
                  <th>TASK DESCRIPTION</th>
                  <th>ASSIGNED</th>
                  <th>LOCATION</th>
                  <th>STATUS</th>
                  <th>START DATE</th>
                  <th>END DATE</th>
                  <th>DURATION (Hrs)</th>
                  <th>MATERIAL COST</th>
                </tr>
              </thead>
              <tbody>
                ${completedTasks.map(row => `
                  <tr>
                    <td>${safeProjectName(row)}</td>
                    <td>${row.taskId || '-'}</td>
                    <td>${row.taskDescription || '-'}</td>
                    <td>${row.assignedTo || '-'}</td>
                    <td>${row.location || '-'}</td>
                    <td>${row.status || '-'}</td>
                    <td>${row.startDate ? (row.startDate.toDate ? row.startDate.toDate().toLocaleDateString() : row.startDate) : '-'}</td>
                    <td>${row.endDate ? (row.endDate.toDate ? row.endDate.toDate().toLocaleDateString() : row.endDate) : '-'}</td>
                    <td>${row._durationHours || '0'}</td>
                    <td>${row._materialCost !== undefined ? row._materialCost.toLocaleString(undefined,{maximumFractionDigits:2}) : '0'}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>`;
        }

        if (showOngoing && ongoingTasks.length > 0) {
          mainHtml += `
          <div class="pdf-section">
            <h3 class="pdf-heading">ONGOING TASKS</h3>
            <table class="report-table">
              <thead>
                <tr>
                  <th>PROJECT</th>
                  <th>TASK ID</th>
                  <th>TASK DESCRIPTION</th>
                  <th>ASSIGNED</th>
                  <th>LOCATION</th>
                  <th>STATUS</th>
                  <th>START DATE</th>
                  <th>DURATION (Hrs)</th>
                  <th>MATERIAL COST</th>
                </tr>
              </thead>
              <tbody>
                ${ongoingTasks.map(row => `
                  <tr>
                    <td>${safeProjectName(row)}</td>
                    <td>${row.taskId || '-'}</td>
                    <td>${row.taskDescription || '-'}</td>
                    <td>${row.assignedTo || '-'}</td>
                    <td>${row.location || '-'}</td>
                    <td>${row.status || '-'}</td>
                    <td>${row.startDate ? (row.startDate.toDate ? row.startDate.toDate().toLocaleDateString() : row.startDate) : '-'}</td>
                    <td>${row._durationHours || '0'}</td>
                    <td>${row._materialCost !== undefined ? row._materialCost.toLocaleString(undefined,{maximumFractionDigits:2}) : '0'}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>`;
        }

        if (showPending && pendingTasks.length > 0) {
          mainHtml += `
          <div class="pdf-section">
            <h3 class="pdf-heading">PENDING TASKS</h3>
            <table class="report-table">
              <thead>
                <tr>
                  <th>PROJECT</th>
                  <th>TASK ID</th>
                  <th>TASK DESCRIPTION</th>
                  <th>ASSIGNED</th>
                  <th>LOCATION</th>
                  <th>STATUS</th>
                  <th>START DATE</th>
                  <th>DURATION (Hrs)</th>
                  <th>MATERIAL COST</th>
                </tr>
              </thead>
              <tbody>
                ${pendingTasks.map(row => `
                  <tr>
                    <td>${safeProjectName(row)}</td>
                    <td>${row.taskId || '-'}</td>
                    <td>${row.taskDescription || '-'}</td>
                    <td>${row.assignedTo || '-'}</td>
                    <td>${row.location || '-'}</td>
                    <td>${row.status || '-'}</td>
                    <td>${row.startDate ? (row.startDate.toDate ? row.startDate.toDate().toLocaleDateString() : row.startDate) : '-'}</td>
                    <td>${row._durationHours || '0'}</td>
                    <td>${row._materialCost !== undefined ? row._materialCost.toLocaleString(undefined,{maximumFractionDigits:2}) : '0'}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>`;
        }

        mainHtml += `</div>`;

        document.getElementById("report-output").innerHTML = mainHtml;
        lastReportHTML = mainHtml;
        lastReportType = reportTypeSelect.value;
        lastReportPeriod = periodLabel;
        document.getElementById("download-pdf-btn").disabled = false;

      } catch (error) {
        console.error("Error generating report:", error);
        document.getElementById("report-output").innerHTML = `<p style="color:red;">Error generating report: ${error.message}</p>`;
      } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = originalBtnText;
      }
    };

   document.getElementById("download-pdf-btn").onclick = function() {
  if (!lastReportHTML) return;
  const section = document.getElementById("report-export-section");

  // sanitize blanks before export
  section.querySelectorAll("td, span, div").forEach(el => {
    if (!el.innerText || el.innerText === "undefined" || el.innerText === "null") {
      el.innerText = "0";  // replace with safe value
    }
  });

  // enforce supported font
  section.style.fontFamily = "Arial, Helvetica, sans-serif";

  const opt = {
    margin: 0.2,
    filename: `${lastReportType}-${lastReportPeriod.replace(/[^a-zA-Z0-9]/g,"_")}-full-report.pdf`,
    image: { type: 'jpeg', quality: 1 },
    html2canvas: { 
      scale: 2, 
      scrollY: 0, 
      useCORS: true, 
      logging: false, 
      windowWidth: document.body.scrollWidth
    },
    jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' },
    pagebreak: { mode: ['avoid-all', 'css', 'legacy'] }
  };

  html2pdf().from(section).set(opt).save();
};


    // Initialize the page
    updateDefaultWeekAndMonth();
  </script>
</body>
</html>
